<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mkozex</title>
  
  <subtitle>胡思乱想啦</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Mkozex.github.io/"/>
  <updated>2020-09-12T12:25:34.555Z</updated>
  <id>http://Mkozex.github.io/</id>
  
  <author>
    <name>Mkozex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DFS</title>
    <link href="http://Mkozex.github.io/2020/09/12/DFS/"/>
    <id>http://Mkozex.github.io/2020/09/12/DFS/</id>
    <published>2020-09-12T14:21:23.000Z</published>
    <updated>2020-09-12T12:25:34.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DFS-序列"><a href="#DFS-序列" class="headerlink" title="DFS 序列"></a>DFS 序列</h2><p>我们可以通过记录调用 DFS 的 <strong>时间戳</strong> 来实现一棵树/图的 DFS 序列。</p><a id="more"></a><p>具体的，我们只需在 <code>PREVISIT</code> 和 <code>POSTVISIT</code> 中添加如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PREVISIT</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    pre[u] = ++tim;</span><br><span class="line">    dfn[tim] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">POSTVISIT</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    post[u] = tim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如下面这棵树：</p><p><img src="https://i.loli.net/2020/03/11/q1VfyFnvN8orzO9.png" alt></p><p>我们可以容易的写出其对应的 <code>pre</code> 、 <code>post</code> 数组：</p><table><thead><tr><th align="center">$i$（结点编号）</th><th align="center">$1$</th><th align="center">$2$</th><th align="center">$3$</th><th align="center">$4$</th><th align="center">$5$</th></tr></thead><tbody><tr><td align="center">$pre[i]$</td><td align="center">$1$</td><td align="center">$2$</td><td align="center">$6$</td><td align="center">$3$</td><td align="center">$5$</td></tr><tr><td align="center">$post[i]$</td><td align="center">$6$</td><td align="center">$5$</td><td align="center">$6$</td><td align="center">$4$</td><td align="center">$5$</td></tr></tbody></table><p>以及 <code>dfn</code> 数组就是 <code>pre</code> 所对应的映射。</p><p>我们可以通过 DFS 序发现许多性质，例如：$pre[i] - post[i]=$ 该节点的子树大小。</p><p>因此，我们可以用 DFS 序完成许多树上问题。</p><h3 id="单点修改，子树和查询"><a href="#单点修改，子树和查询" class="headerlink" title="单点修改，子树和查询"></a>单点修改，子树和查询</h3><p><a href="https://loj.ac/problem/144" target="_blank" rel="noopener">LOJ 144</a></p><p>可利用树状数组完成， $pre [i]$ 单点加，$pre[i]\sim post[i]$ 区间查询。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line">ll pre[N], post[N], sz[N], t[N];</span><br><span class="line"><span class="keyword">int</span> tim = <span class="number">0</span>, n, m, rt, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    pre[u] = ++tim;</span><br><span class="line">    <span class="keyword">int</span> d = G[u].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">        <span class="keyword">if</span> (v == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    post[u] = tim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += lowbit(x)) t[x] += k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= lowbit(x)) ans += t[x];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;m, &amp;rt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">        G[u].push_back(v);</span><br><span class="line">        G[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(rt, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        add(pre[i], a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;opt);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">            add(pre[x], y);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(post[x]) - query(pre[x] - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子树修改，子树和查询"><a href="#子树修改，子树和查询" class="headerlink" title="子树修改，子树和查询"></a>子树修改，子树和查询</h3><p><a href="https://loj.ac/problem/145" target="_blank" rel="noopener">LOJ 145</a></p><p>用两个树状数组或者线段树（可能要卡空间）， $pre[i]\sim post[i]$ 区间加，区间查询。</p><p>不过，这道题好像暴力也可以搞过去？</p><h2 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对于树上的每一个点，计算其所有子树中最大的子树节点数，这个值最小的点就是这棵树的重心。</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>1.以树的重心为根时，所有子树的大小都不超过整棵树大小的一半。</p><p>2.树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。</p><p>3.把两棵树通过一条边相连得到一棵新的树，那么新的树的重心在连接原来两棵树的重心的路径上。</p><p>4.在一棵树上添加或删除一个叶子，那么它的重心最多只移动一条边的距离。</p><p><strong>5.一棵树的重心一定在这棵树的重链上</strong></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>在 DFS 中计算每个子树的大小，记录“向下”的子树的最大大小，利用总点数 - 当前子树（这里的子树指有根树的子树）的大小得到“向上”的子树的大小，然后就可以依据定义找到重心了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Centroid</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">siz[u] = <span class="number">1</span>;</span><br><span class="line">son[u] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> d = G[u].size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> v = G[u][i];</span><br><span class="line"><span class="keyword">if</span> (v != fa) P&#123;</span><br><span class="line">Centroid(v, u);</span><br><span class="line">siz[u] += siz[v];</span><br><span class="line">son[u] = max(son[u], n - siz[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">    son[u] = max(son[u], n - siz[u]);</span><br><span class="line"><span class="keyword">if</span> (rt == <span class="number">0</span> || son[u] &lt; son[rt]) &#123;</span><br><span class="line">rt = u; <span class="comment">// rt为重心编号 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DFS-序列&quot;&gt;&lt;a href=&quot;#DFS-序列&quot; class=&quot;headerlink&quot; title=&quot;DFS 序列&quot;&gt;&lt;/a&gt;DFS 序列&lt;/h2&gt;&lt;p&gt;我们可以通过记录调用 DFS 的 &lt;strong&gt;时间戳&lt;/strong&gt; 来实现一棵树/图的 DFS 序列。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://Mkozex.github.io/categories/Algorithm/"/>
    
    
      <category term="图论" scheme="http://Mkozex.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="DFS序" scheme="http://Mkozex.github.io/tags/DFS%E5%BA%8F/"/>
    
      <category term="DFS" scheme="http://Mkozex.github.io/tags/DFS/"/>
    
      <category term="学习笔记" scheme="http://Mkozex.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="LOJ" scheme="http://Mkozex.github.io/tags/LOJ/"/>
    
  </entry>
  
  <entry>
    <title>「IMO2019」T1</title>
    <link href="http://Mkozex.github.io/2020/03/22/%E3%80%8CIMO2019%E3%80%8D%E8%A7%A3%E7%AD%94/"/>
    <id>http://Mkozex.github.io/2020/03/22/「IMO2019」解答/</id>
    <published>2020-03-22T11:44:13.000Z</published>
    <updated>2020-03-23T06:04:39.026Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了质心关于 IMO2019 的解答，但是只会第 $1$ 题，于是就想记录一下。</p><a id="more"></a><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>设整数集为 $\mathbb{Z}.$ 求所有函数 $f:\mathbb{Z} \to \mathbb{Z}$ 使得对任意整数 $a,b$ 都有<br>$$<br>f(2a) + 2f(b) = f(f(a + b)).<br>$$</p><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><p>我们可以用 $a + 1$ 替换 $a$ ，用 $b - 1$ 替换 $b$ 。</p><p>于是原方程变为<br>$$<br>f(2a + 2) + 2f(b - 1) = f(f(a + b))<br>$$<br>然后与原式作差<br>$$<br>f(2a + 2) - f(2a) = 2(f(b) - f(b - 1))<br>$$<br>将 $a = 0$ 代入<br>$$<br>f(b) - f(b - 1) = \frac{f(2) - f(0)}{2}<br>$$<br>于是可以得到该函数为线性增长的函数，因此，设 $f(0) = m$ ，可得 $f(x) = m + dx$ 。</p><p>接下来分类讨论</p><p>$\mathbb{1.}\ d = 0\ ,\ f(x) = m.$ </p><p>将 $a = b = 0$ 代入<br>$$<br>\begin{align}<br>f(0) + 2f(0) &amp;= f(f(0)) \newline<br>3m &amp;= m\newline<br>\therefore m &amp;= 0<br>\end{align}<br>$$<br>所以 $f(x) = 0$ 。</p><p>$\mathbb{2.}\ d \neq 0.$<br>$$<br>\begin{align}<br>f(0) + 2f(0) &amp;= f(f(0))\newline<br>3m &amp;= f(m)\newline<br>\therefore dm &amp;= 2m<br>\end{align}<br>$$<br>然后再分情况考虑</p><p>$\mathbb{2.1.}\ m = 0\ ,\ f(x) = dx.$</p><p>代入原式<br>$$<br>\begin{align}<br>2ad + 2bd &amp;= f((a + b)d) = (a + b)d^2\newline<br>2d(a + b) &amp;= d^2 (a + b)\newline<br>\therefore d &amp;= 2<br>\end{align}<br>$$<br>所以 $f(x) = 2x$ 。</p><p>$\mathbb{2.2.}\ m \neq 0\ ,\ d = 2.$</p><p>此时 $f(x) = 2x + m$ 。</p><p>代入原式<br>$$<br>\begin{align}<br>4a + m + 2 (2b + m) &amp;= f(2a + 2b +m) = 2(2a + 2b + m) + m\newline<br>4a + 4b + 3m &amp;= 4a + 4b + 3m\newline<br>\therefore m &amp;\in \mathbb{Z}<br>\end{align}<br>$$<br>综上所述 $f(x) = 0$ 或 $f(x) = 2x + m\ ,\ m \in \mathbb{Z}$ 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了质心关于 IMO2019 的解答，但是只会第 $1$ 题，于是就想记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Mathematic" scheme="http://Mkozex.github.io/categories/Mathematic/"/>
    
    
      <category term="Math" scheme="http://Mkozex.github.io/tags/Math/"/>
    
      <category term="函数" scheme="http://Mkozex.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>FHQ-Treap</title>
    <link href="http://Mkozex.github.io/2020/03/05/FHQ-Treap/"/>
    <id>http://Mkozex.github.io/2020/03/05/FHQ-Treap/</id>
    <published>2020-03-05T08:21:23.000Z</published>
    <updated>2020-03-08T09:57:07.803Z</updated>
    
    <content type="html"><![CDATA[<p>“平衡树好麻烦啊，转来转去的，好难理解啊，而且 $\text{Treap}$ 还不能解决区间序列问题。”</p><p>“有一种无旋的 $\text{Treap}$ ，叫 $\text{FHQ-Treap}$ ，还可以解决区间序列问题呢！”</p><a id="more"></a><h2 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h2><p>因为 $\text{FHQ-Treap}$ 是基于 $\text{Treap}$ 的所以需要先大致了解一下 $\text{Treap}$ 的性质。</p><p>顾名思义， $\text{Treap = Tree + Heap}$ ，因此， $\text{Treap}$ 被称作树堆，是指一有一个<strong>随机附加域</strong>满足堆的性质的二叉搜索树，其结构相当于以随机数据插入的二叉搜索树。其基本操作的期望时间复杂度为 $O(\log n)$ ，能基本实现随机平衡的结构。</p><p>相对于 $\text{Treap}$ ， $\text{FHQ-Treap}$ 的代码更为简洁，且省去了繁琐的旋转操作，降低了调试难度。 </p><h2 id="核心操作"><a href="#核心操作" class="headerlink" title="核心操作"></a>核心操作</h2><h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><p>$\text{FHQ-Treap}$ 的分割分为两种，一种是按照权值分割，一种是按照大小分割。（图丑不要介意qwq</p><h4 id="按照权值分割"><a href="#按照权值分割" class="headerlink" title="按照权值分割"></a>按照权值分割</h4><p><img src="https://i.loli.net/2020/03/05/MNULRuQY29tpcjb.png" alt></p><p>权值分割即是将权值按照 $val$ 分割 $\ge\ val$ 和 $&lt; val$ 成两部分。</p><p>例如，对于图中的树，我们假设要将其按照 $val = 75$ 分成两部分。</p><p>那么第一次分割，此时根节点为橙色结点，因为 $50&lt;75$ ，又因为平衡树的性质，所以就按照<strong>红线</strong>分成了两部分。</p><p>第二次分割，此时根节点变为了黄色结点，因为 $80 &gt; 75$ ，所以就按照<strong>蓝线</strong>又分成了两部分。</p><p>第三次分割，此时根节点变成了粉色结点，因为 $70 &lt; 75$ ，所以将这个叶结点归为 $&lt;75$ 的部分。</p><p>至此，这棵树就按照 $val = 75$ 分成了两部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split_val</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> val, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line">x = y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (t[p].val &lt;= val) &#123;</span><br><span class="line">x = p;</span><br><span class="line">split_val(rs(p), val, rs(p), y);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">y = p;</span><br><span class="line">split_val(ls(p), val, x, ls(p));</span><br><span class="line">&#125;</span><br><span class="line">up(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="按照大小分割"><a href="#按照大小分割" class="headerlink" title="按照大小分割"></a>按照大小分割</h4><p>大小分割即是将前 $k$ 个结点</p><p><img src="https://i.loli.net/2020/03/05/EZ8O3rDHojPxcqg.png" alt></p><p>例如，对于图中的树，我们假设要将其前 $4$ 个结点分割出来。</p><p>那么第一次分割，此时根节点为橙色结点，因为左子树的大小 $+1&lt;4$ ，所以就按照<strong>红线</strong>分成了两部分。</p><p>第二次分割，此时根节点变为了黄色结点，因为左子树的大小 $+1=4$ ，所以就按照<strong>蓝线</strong>又分成了两部分，并且将剩下的粉色结点归为另一部分中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split_sz</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line">x = y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (t[ls(p)].sz + <span class="number">1</span> &lt;= k) &#123;</span><br><span class="line">x = p;</span><br><span class="line">split_sz(rs(p), k - t[ls(p)].sz - <span class="number">1</span>, rs(p), y);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">y = p;</span><br><span class="line">split_sz(ls(p), k, x, ls(p));</span><br><span class="line">&#125;</span><br><span class="line">up(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><img src="https://i.loli.net/2020/03/05/6nqAOIYZvRNx74F.png"><p>（画图好难）假设现在我们要合并 $x$ 和 $y$ ，那么此时我们可以通过比较随机附加域的大小来合并。</p><p>注：图中的红色结点为当前根节点。</p><p>图 $1$ ，因为 $rd_x &lt; rd_y$ ，于是我们固定 $x$ 以及它的左子树，让它的右子树继续和 $y$ 合并。</p><p>接下来图 $2$ ，因为此时 $rd_x &gt; rd_y$ ，于是我们固定 $y$ 以及它的右子树（也就是让 $y$ 与根节点合并），让它的左子树继续和 $x$ 合并。</p><p>同理，可依次得到图 $3,\ 4,\ 5 $ ，最后返回最后合并的结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span>) <span class="keyword">return</span> x + y;</span><br><span class="line"><span class="keyword">if</span> (t[x].rd &lt; t[y].rd) &#123;</span><br><span class="line">rs(x) = merge(rs(x), y);</span><br><span class="line">up(x);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ls(y) = merge(x, ls(y));</span><br><span class="line">up(y);</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><p>因为 $\text{FHQ-Treap}$ 运用了函数式变成的方法，因此，其他操作都是通过 $\text{split}$ 和 $\text{merge}$ 实现的。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入可以直接按照新的结点的权值分割，然后将结点放到第一棵树的后面，然后依次合并。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">split_val(rt, val, x, y);</span><br><span class="line">rt = merge(merge(x, newnode(val)), y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 <code>noewnode</code> 就是新建一个结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">t[++tot].sz = <span class="number">1</span>;</span><br><span class="line">t[tot].val = val, t[tot].rd = rand();</span><br><span class="line"><span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>因为权值为 $val$ 的结点可能有多个，所以我们可以先按照 $val$ 进行权值分割，用 $x$ 记录这个根，再在 $x$ 树中按照 $val - 1$ 再次进行权值分割，并且用 $y$ 记录这个根。</p><p>那么此时 $val$ 这个权值已经被分离到了以 $y$ 为根的树中，即可直接将这个结点的位置用它的左儿子和右儿子合并后的根代替。最后将分割出来的树依次合并就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y, z</span><br><span class="line">split_val(rt, val, x, z);</span><br><span class="line">split_val(x, val - <span class="number">1</span>, x, y);</span><br><span class="line">y = merge(ls(y), rs(y));</span><br><span class="line">rt = merge(x, merge(y, z));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询排名"><a href="#查询排名" class="headerlink" title="查询排名"></a>查询排名</h3><p>我们可以直接将所有比要查询的数小的权值分割到一棵树中，那么这个数的排名就是分割出的这棵树 $+1$ 了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">split_val(rt, val - <span class="number">1</span>, x, y);</span><br><span class="line"><span class="keyword">int</span> ans = t[x].sz + <span class="number">1</span>;</span><br><span class="line">rt = merge(x, y);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第k大数"><a href="#第k大数" class="headerlink" title="第k大数"></a>第k大数</h3><p>我们可以把前 $k - 1$ 个数拿出来，再从剩下的树中找第 $1$ 个元素就是答案了。用 <code>split_sz</code> 就可以实现啦。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y, z;</span><br><span class="line">split_sz(rt, p - <span class="number">1</span>, x, y);</span><br><span class="line">split_sz(y, <span class="number">1</span>, y, z);</span><br><span class="line"><span class="keyword">int</span> ans = y;</span><br><span class="line">rt = merge(merge(x, y), z);</span><br><span class="line"><span class="keyword">return</span> ans;<span class="comment">//返回第k大数的序号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询前驱"><a href="#查询前驱" class="headerlink" title="查询前驱"></a>查询前驱</h3><p>先得到 $1$ 到 $val - 1$ 构成的树，然后用 <code>kth</code> 函数即可求出最大的元素， 即是前驱。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">split_val(rt, val - <span class="number">1</span>, x, y);</span><br><span class="line"><span class="keyword">int</span> ans = kth(x, t[x].sz);</span><br><span class="line">rt = merge(x, y);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询后继"><a href="#查询后继" class="headerlink" title="查询后继"></a>查询后继</h3><p>同查询前驱一样，我们可以先得到 $1 - v$ 构成的树，再用 <code>kth</code> 求出剩下树中最小的与元素，即是后继。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">suc</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">split_val(rt, val, x, y);</span><br><span class="line"><span class="keyword">int</span> ans = kth(y, <span class="number">1</span>);</span><br><span class="line">rt = merge(x, y);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://loj.ac/problem/104" target="_blank" rel="noopener">LOJ 104普通平衡树</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) t[x].ch[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) t[x].ch[1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>, rt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> ch[<span class="number">2</span>], val, sz, rd;</span><br><span class="line">&#125; t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">t[x].sz = t[ls(x)].sz + t[rs(x)].sz + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split_val</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> val, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line">x = y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (t[p].val &lt;= val) &#123;</span><br><span class="line">x = p;</span><br><span class="line">split_val(rs(p), val, rs(p), y);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">y = p;</span><br><span class="line">split_val(ls(p), val, x, ls(p));</span><br><span class="line">&#125;</span><br><span class="line">up(p);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split_sz</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;</span><br><span class="line">x = y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (t[ls(p)].sz + <span class="number">1</span> &lt;= k) &#123;</span><br><span class="line">x = p;</span><br><span class="line">split_sz(rs(p), k - t[ls(p)].sz - <span class="number">1</span>, rs(p), y);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">y = p;</span><br><span class="line">split_sz(ls(p), k, x, ls(p));</span><br><span class="line">&#125;</span><br><span class="line">up(p);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span>) <span class="keyword">return</span> x + y;</span><br><span class="line"><span class="keyword">if</span> (t[x].rd &lt; t[y].rd) &#123;</span><br><span class="line">rs(x) = merge(rs(x), y);</span><br><span class="line">up(x);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ls(y) = merge(x, ls(y));</span><br><span class="line">up(y);</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">t[++tot].sz = <span class="number">1</span>;</span><br><span class="line">t[tot].val = val, t[tot].rd = rand();</span><br><span class="line"><span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">split_val(rt, val, x, y);</span><br><span class="line">rt = merge(merge(x, newnode(val)), y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y, z;</span><br><span class="line">split_val(rt, val, x, z);</span><br><span class="line">split_val(x, val - <span class="number">1</span>, x, y);</span><br><span class="line">y = merge(ls(y), rs(y));</span><br><span class="line">rt = merge(merge(x, y), z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">split_val(rt, val - <span class="number">1</span>, x, y);</span><br><span class="line"><span class="keyword">int</span> ans = t[x].sz + <span class="number">1</span>;</span><br><span class="line">rt = merge(x, y);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y, z;</span><br><span class="line">split_sz(rt, p - <span class="number">1</span>, x, y);</span><br><span class="line">split_sz(y, <span class="number">1</span>, y, z);</span><br><span class="line"><span class="keyword">int</span> ans = y;</span><br><span class="line">rt = merge(merge(x, y), z);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">split_val(rt, val - <span class="number">1</span>, x, y);</span><br><span class="line"><span class="keyword">int</span> ans = kth(x, t[x].sz);</span><br><span class="line">rt = merge(x, y);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">suc</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">split_val(rt, val, x, y);</span><br><span class="line"><span class="keyword">int</span> ans = kth(y, <span class="number">1</span>);</span><br><span class="line">rt = merge(x, y);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line"><span class="keyword">int</span> opt, x;</span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;opt, &amp;x);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">1</span>) insert(x);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">2</span>) remove(x);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rank(x));</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t[kth(rt, x)].val);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t[pre(x)].val);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t[suc(x)].val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“平衡树好麻烦啊，转来转去的，好难理解啊，而且 $\text{Treap}$ 还不能解决区间序列问题。”&lt;/p&gt;
&lt;p&gt;“有一种无旋的 $\text{Treap}$ ，叫 $\text{FHQ-Treap}$ ，还可以解决区间序列问题呢！”&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://Mkozex.github.io/categories/Algorithm/"/>
    
    
      <category term="学习笔记" scheme="http://Mkozex.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据结构" scheme="http://Mkozex.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="平衡树" scheme="http://Mkozex.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
      <category term="FHQ-Treap" scheme="http://Mkozex.github.io/tags/FHQ-Treap/"/>
    
  </entry>
  
  <entry>
    <title>「CSMO」一道有趣的集合问题</title>
    <link href="http://Mkozex.github.io/2020/02/27/%E3%80%8CCSMO%E3%80%8D%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E9%9B%86%E5%90%88%E9%97%AE%E9%A2%98/"/>
    <id>http://Mkozex.github.io/2020/02/27/「CSMO」一道有趣的集合问题/</id>
    <published>2020-02-27T01:57:30.000Z</published>
    <updated>2020-02-27T05:14:28.919Z</updated>
    
    <content type="html"><![CDATA[<p>设 $x, y, z, u\in \mathbb{Z}\ , 1\le x, y, z, u\le 10$ ，求试下列不等式成立的有序四元数组 $(x, y, z, y)$ 的个数：<br>$$<br>\frac{x-y}{x+y}+\frac{y-z}{y + z}+\frac{z-u}{z+u}+\frac{u-x}{u+x} &gt; 0<br>$$</p><a id="more"></a><p>看到的一道题，看上去十分的不可做，看了一下提示，终于弄出来了。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>令<br>$$<br>\begin{align}<br>&amp;f(a, b, c,d) = \frac{a-b}{a+b}+\frac{b-c}{b + c}+\frac{c-d}{c+d}+\frac{d-a}{d+a}\newline<br>A &amp;= {(x,y,z,u)\ |\ 1\le x,y,z,u \le 10,\ f(x,y,z,u) &gt; 0 }\newline<br>B &amp;= {(x,y,z,u)\ |\ 1\le x,y,z,u \le 10,\ f(x,y,z,u) &lt; 0 }\newline<br>C &amp;= {(x,y,z,u)\ |\ 1\le x,y,z,u \le 10,\ f(x,y,z,u) = 0 }<br>\end{align}<br>$$<br>题目要求的即是 $|A|$ 。</p><p>因为 $x,y,z,y$ 均有 $10$ 种情况，于是有<br>$$<br>|A|+|B|+|C| = 10^4<br>$$<br>由<br>$$<br>\begin{align}<br>f(x,y,z,u) &gt; 0&amp;\iff \frac{y-x}{x+y}+\frac{z-y}{y + z}+\frac{u-z}{z+u}+\frac{x-u}{u+x} &lt; 0\newline<br>&amp;\iff \frac{x-u}{x+u}+\frac{u-z}{u + z}+\frac{z-y}{z+y}+\frac{y-x}{y+x} &gt; 0\newline<br>&amp;\iff f(x,u,z,y) &lt; 0<br>\end{align}<br>$$<br>得 $|A| = |B|$ 。</p><p>下面计算 $|C|$<br>$$<br>\begin{align}<br>&amp;\frac{x-y}{x+y}+\frac{y-z}{y + z}+\frac{z-u}{z+u}+\frac{u-x}{u+x} = 0\newline<br>\iff &amp;\frac{xz-yu}{(x+y)(z+u)} = \frac{xz-yu}{(y+z)(x+u)}\newline<br>\iff &amp;(xz-yu)(xy+zu-yu-xu) = 0\newline<br>\iff &amp;(xz-yu)(z-x)(u-y) = 0<br>\end{align}<br>$$<br>令<br>$$<br>\begin{align}<br>C_1 &amp;= { (x, y, z, u)\ |\ x = z }\newline<br>C_1 &amp;= { (x, y, z, u)\ |\ x \neq z,\ y = u }\newline<br>C_1 &amp;= { (x, y, z, u)\ |\ x =\neq z,\ y \ne u ,\ xz = yu}<br>\end{align}<br>$$<br>$\Rightarrow |C_1| = 10^3,\ |C_2| = 900$ 。</p><p>下面求 $|C_3|$ ， 有 $3$ 种情况：</p><p>$\mathbf{1.}\ x \neq z, x = y, z = u \Rightarrow 90$ 种 </p><p>$\mathbf{2.}\ x \neq z, x = u, y = z \Rightarrow 90$ 种</p><p>$\mathbf{3.}\ xz \neq yu$ ， 且 $x,y,z,u$ 互不相等</p><p>枚举得到有<br>$$<br>\begin{align}<br>&amp;(1,6,2,3)&amp; &amp;(1,8,2,4)&amp; &amp;(1,10,2,5)\newline<br>&amp;(2,6,3,4)&amp; &amp;(2,9,3,6)&amp; &amp;(3,8,4,6)\newline<br>&amp;(3,10,5,6)&amp; &amp;(4,10,5,8)&amp; &amp;(2,10,4,5)<br>\end{align}<br>$$<br>又因为四元数组有序，所以每组有 $2\times 4 = 8$ 种排列，因此有 $8 \times 9 = 72$ 种。</p><p>所以可以得到 $|C| = |C_1|+|C_2|+|C_3|=2152$ 。</p><p>因此题目所求 $= |A| = \frac{10^4 - |C|}{2} = 3924$ 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设 $x, y, z, u\in \mathbb{Z}\ , 1\le x, y, z, u\le 10$ ，求试下列不等式成立的有序四元数组 $(x, y, z, y)$ 的个数：&lt;br&gt;$$&lt;br&gt;\frac{x-y}{x+y}+\frac{y-z}{y + z}+\frac{z-u}{z+u}+\frac{u-x}{u+x} &amp;gt; 0&lt;br&gt;$$&lt;/p&gt;
    
    </summary>
    
      <category term="Mathematic" scheme="http://Mkozex.github.io/categories/Mathematic/"/>
    
    
      <category term="Math" scheme="http://Mkozex.github.io/tags/Math/"/>
    
      <category term="集合" scheme="http://Mkozex.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>「NOI2001」食物链-种类并查集</title>
    <link href="http://Mkozex.github.io/2020/02/25/%E3%80%8CNOI2001%E3%80%8D%E9%A3%9F%E7%89%A9%E9%93%BE-%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://Mkozex.github.io/2020/02/25/「NOI2001」食物链-种类并查集/</id>
    <published>2020-02-25T09:40:39.000Z</published>
    <updated>2020-02-27T06:30:57.283Z</updated>
    
    <content type="html"><![CDATA[<p>动物王国中有三类动物 ${A,\ B,\ C}$，这三类动物的食物链构成了有趣的环形。${A}$  吃 ${B}$ ， ${B}$ 吃 ${C}$ ， ${C}$ 吃 ${A}$ 。现有 $N$ 个动物，以 $1-N$ 编号。每个动物都是 ${A,\ B,\ C} $ 中的一种，但是我们并不知道它到底是哪一种。</p><p>有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：</p><p>第一种说法是“ ${1\  X\ Y}$ ”，表示 ${X}$ 和 ${Y}$ 是同类。</p><p>第二种说法是“ ${2\ X\ Y}$ ”，表示 ${X}$ 吃 ${Y}$ 。</p><p>此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p><ul><li><p>当前的话与前面的某些真的话冲突，就是假话</p></li><li><p>当前的话中 ${X}$ 或 ${Y}$ 比 $N$ 大，就是假话</p></li><li><p>当前的话表示 ${X}$ 吃 ${X}$，就是假话</p></li></ul><p>你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。</p><a id="more"></a><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.luogu.com.cn/problem/P2024" target="_blank" rel="noopener">Luogu P2024</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>众所周知，普通的并查集能够维护连通性与传递性。但对于这道题目，存在生产、消费和中立的三种情况，就不能用简单的并查集维护了，于是就有了<code>种类并查集</code>。</p><p>对于本题，我们可以将并查集分为 $3$ 个部分，分别表示生产 $(A)$ 、消费 $(B)$ 、中立 $(C)$ 的情况。即： $1-n$ 为 $A$ 群系， $n-2n$ 为 $B$ 群系， $2n-3n$ 为 $C$ 群系。</p><p>于是，每当有一句真话时，就要对这三组元素都加以合并。</p><p>接下来就是对于假话的判断：</p><p>当一句话表示 $X$ 和 $Y$ 是同类时，只要判断它们是否有吃或被吃的关系即可。</p><p>当一句话表示 $X$ 吃 $Y$ 时，只要判断它们是否是同类或者是否有 $X$ 被 $Y$ 吃的情况即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> +<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">3</span> * N], n, k, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> fa[x] = find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span> * n; ++i) fa[i] = i;</span><br><span class="line"><span class="keyword">int</span> opt, x, y;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;opt, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">if</span> (x &gt; n || y &gt; n) &#123;</span><br><span class="line">ans++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (find(x + n) == find(y) || find(x) == find(y + n)) ans++;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">fa[find(x)] = find(y);</span><br><span class="line">fa[find(x + n)] = find(y + n);</span><br><span class="line">fa[find(x + n + n)] = find(y + n + n);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (find(x) == find(y) || find(x) == find(y + n)) ans++;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">fa[find(x + n)] = find(y);</span><br><span class="line">fa[find(x + n + n)] = find(y + n);</span><br><span class="line">fa[find(x)] = find(y + n + n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动物王国中有三类动物 ${A,\ B,\ C}$，这三类动物的食物链构成了有趣的环形。${A}$  吃 ${B}$ ， ${B}$ 吃 ${C}$ ， ${C}$ 吃 ${A}$ 。现有 $N$ 个动物，以 $1-N$ 编号。每个动物都是 ${A,\ B,\ C} $ 中的一种，但是我们并不知道它到底是哪一种。&lt;/p&gt;
&lt;p&gt;有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：&lt;/p&gt;
&lt;p&gt;第一种说法是“ ${1\  X\ Y}$ ”，表示 ${X}$ 和 ${Y}$ 是同类。&lt;/p&gt;
&lt;p&gt;第二种说法是“ ${2\ X\ Y}$ ”，表示 ${X}$ 吃 ${Y}$ 。&lt;/p&gt;
&lt;p&gt;此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当前的话与前面的某些真的话冲突，就是假话&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当前的话中 ${X}$ 或 ${Y}$ 比 $N$ 大，就是假话&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当前的话表示 ${X}$ 吃 ${X}$，就是假话&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。&lt;/p&gt;
    
    </summary>
    
      <category term="Solution" scheme="http://Mkozex.github.io/categories/Solution/"/>
    
    
      <category term="Luogu" scheme="http://Mkozex.github.io/tags/Luogu/"/>
    
      <category term="数据结构" scheme="http://Mkozex.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="并查集" scheme="http://Mkozex.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>「ZROI」徐强强-欧拉公式+平面图</title>
    <link href="http://Mkozex.github.io/2020/02/24/%E3%80%8CZROJ%E3%80%8D%E5%BE%90%E5%BC%BA%E5%BC%BA/"/>
    <id>http://Mkozex.github.io/2020/02/24/「ZROJ」徐强强/</id>
    <published>2020-02-24T08:15:20.000Z</published>
    <updated>2020-03-11T07:15:24.494Z</updated>
    
    <content type="html"><![CDATA[<p>有一个无穷大的二维平面和一个点，现在有 $n\ (n\le 5\times 10^6)$ 个操作其中每次操作都是将这个点往上、下、左、右四个方向移动一个单位长度。求移动的路径能将平面分成多少个联通区域。<strong>外面无限大的平面也算作一个连通区域</strong></p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>可以运用欧拉公式 $V + E - F =2$ 。</p><p>这虽然是对于三维几何体的公式，但也可以放到二维平面中， $F$ 为联通区域个数， $E$ 为边数， $V$ 为点数。</p><p>统计时为了去重，可以开两个 $\texttt{set}$ 分别维护点集和边集即可，复杂度 $O(n\log n)$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;pii&gt; S1;</span><br><span class="line"><span class="built_in">set</span>&lt;pair&lt;pii, pii&gt; &gt; S2; </span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">S1.insert(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x = <span class="number">0</span>, y = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> a = x, b = y;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">'L'</span>) x++;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">'R'</span>) x--;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">'U'</span>) y++;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">'D'</span>) y--;</span><br><span class="line">S1.insert(&#123;x, y&#125;);</span><br><span class="line"><span class="keyword">int</span> c = x, d = y;</span><br><span class="line"><span class="keyword">if</span> (a &gt; c || b &gt; d) swap(a, c), swap(b, d);</span><br><span class="line">S2.insert(&#123;&#123;a, b&#125;, &#123;c, d&#125;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> V = S1.size(), E = S2.size();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, E - V + <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一个无穷大的二维平面和一个点，现在有 $n\ (n\le 5\times 10^6)$ 个操作其中每次操作都是将这个点往上、下、左、右四个方向移动一个单位长度。求移动的路径能将平面分成多少个联通区域。&lt;strong&gt;外面无限大的平面也算作一个连通区域&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Solution" scheme="http://Mkozex.github.io/categories/Solution/"/>
    
    
      <category term="ZROJ" scheme="http://Mkozex.github.io/tags/ZROJ/"/>
    
      <category term="平面图" scheme="http://Mkozex.github.io/tags/%E5%B9%B3%E9%9D%A2%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>「FJOI2007」轮状病毒-找规律</title>
    <link href="http://Mkozex.github.io/2020/02/11/%E3%80%8CFJOI2007%E3%80%8D%E8%BD%AE%E7%8A%B6%E7%97%85%E6%AF%92/"/>
    <id>http://Mkozex.github.io/2020/02/11/「FJOI2007」轮状病毒/</id>
    <published>2020-02-11T03:22:23.000Z</published>
    <updated>2020-02-25T14:43:16.666Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/02/11/1BdY6XAEWxuKUsy.gif" alt="1.jpg"></p><p>给定 $n$ ，变成计算有多少个不同的 $n$ 轮状病毒。</p><a id="more"></a><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1002" target="_blank" rel="noopener">BZOJ 1002</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一开始看感觉很不可做，然后就开始找规律。</p><p>我们设其为 $f_i$。</p><p>通过手玩可以发现前几项为：<br>$$<br>1,5,16,45,121,\cdots<br>$$<br>可以发现奇数项都是平方数，偶数项都是 $5$ 乘上一个平方数，但这个好像没什么用。</p><p>后来，我又观察到了 $f_i$ 与 $f_{i - 1} \times 3$ 很接近。通过一系列的<del>乱搞</del>加加减减弄出了如下式子：<br>$$<br>f_{i} = f_{i - 1} \times 3 - f_{i - 2} + 2<br>$$<br>之后，把它扔到<a href="oeis.org">oeis.org</a>上，结果$^{\text{TM}}$还真是这玩意（找规律带师）。发现这个东西好像要用什么基尔霍夫矩阵推出来（懵）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>因为这个没有给模数，只能写高精了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bint</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> s[<span class="number">110</span>], len;</span><br><span class="line">&#125; f[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">Bint <span class="title">mul</span><span class="params">(Bint a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a.len; ++i) a.s[i] *= k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a.len; ++i) &#123;</span><br><span class="line">a.s[i + <span class="number">1</span>] += a.s[i] / <span class="number">10</span>;</span><br><span class="line">a.s[i] %= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a.s[a.len + <span class="number">1</span>] != <span class="number">0</span>) a.len++;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Bint <span class="title">sub</span><span class="params">(Bint a, Bint b)</span> </span>&#123;</span><br><span class="line">a.s[<span class="number">1</span>] += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">while</span> (a.s[k] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">a.s[k] %= <span class="number">10</span>;</span><br><span class="line">a.s[k + <span class="number">1</span>]++;</span><br><span class="line">k++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a.len; ++i) &#123;</span><br><span class="line">a.s[i] -= b.s[i];</span><br><span class="line"><span class="keyword">if</span> (a.s[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">a.s[i] += <span class="number">10</span>;</span><br><span class="line">a.s[i + <span class="number">1</span>]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (a.s[a.len] == <span class="number">0</span>) a.len--;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">f[<span class="number">1</span>].s[<span class="number">1</span>] = <span class="number">1</span>, f[<span class="number">2</span>].s[<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">f[<span class="number">1</span>].len = <span class="number">1</span>, f[<span class="number">2</span>].len = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) f[i] = sub(mul(f[i - <span class="number">1</span>], <span class="number">3</span>), f[i - <span class="number">2</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = f[n].len; i &gt; <span class="number">0</span>; --i) <span class="built_in">printf</span>(<span class="string">"%d"</span>, f[n].s[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/02/11/1BdY6XAEWxuKUsy.gif&quot; alt=&quot;1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;给定 $n$ ，变成计算有多少个不同的 $n$ 轮状病毒。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://Mkozex.github.io/categories/Algorithm/"/>
    
    
      <category term="BZOJ" scheme="http://Mkozex.github.io/tags/BZOJ/"/>
    
      <category term="找规律" scheme="http://Mkozex.github.io/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="http://Mkozex.github.io/2020/02/03/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>http://Mkozex.github.io/2020/02/03/单调栈/</id>
    <published>2020-02-03T02:11:31.000Z</published>
    <updated>2020-03-05T03:43:06.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是单调栈"><a href="#什么是单调栈" class="headerlink" title="什么是单调栈"></a>什么是单调栈</h2><p>单调栈是满足单调性的栈结构。分为单调递增栈和单调递减栈。</p><a id="more"></a><h2 id="如何使用单调栈"><a href="#如何使用单调栈" class="headerlink" title="如何使用单调栈"></a>如何使用单调栈</h2><p>下面以单调递增栈为例。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>向单调栈之中插入元素时，为了维护栈的单调性，需要弹出比它小的元素。</p><p>例如，栈中自顶向下的元素为 $1, 3, 5, 7, 10, 15$ ，现在要插入元素 $8$ ,为了保证栈的单调性就需要一次弹出元素 $1,3,5,7$ ，操作后栈变为 $8, 10, 15$ 。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"><span class="keyword">while</span> (!s.empty() &amp;&amp; x &gt;= s.top()) s.pop();</span><br><span class="line">s.push(x);</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>可从栈顶取出来一个元素，该元素满足单调性的某一端。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="Luogu-P5788-【模板】单调栈"><a href="#Luogu-P5788-【模板】单调栈" class="headerlink" title="[Luogu P5788] 【模板】单调栈"></a><a href="https://www.luogu.com.cn/problem/P5788" target="_blank" rel="noopener">[Luogu P5788] 【模板】单调栈</a></h3><p>因为这道题要存的是元素的下标，所以我们在单调栈中存的是元素的下标。并且这道题略有卡常，于是改了一下输出。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N], f[N];</span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line"><span class="keyword">while</span> (!s.empty() &amp;&amp; a[s.top()] &lt;= a[i]) s.pop();</span><br><span class="line"><span class="keyword">if</span> (s.empty()) f[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> f[i] = s.top();</span><br><span class="line">s.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d"</span>, f[i]), <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="POJ3250-Bad-Hair-Day"><a href="#POJ3250-Bad-Hair-Day" class="headerlink" title="[POJ3250] Bad Hair Day"></a><a href="http://poj.org/problem?id=3250" target="_blank" rel="noopener">[POJ3250] Bad Hair Day</a></h3><p>这道题也是单调栈的一个简单应用，只需记录栈的大小即可。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, x;</span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"><span class="keyword">while</span> (!s.empty() &amp;&amp; x &gt;= s.top()) s.pop();</span><br><span class="line">ans += s.size();</span><br><span class="line">s.push(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是单调栈&quot;&gt;&lt;a href=&quot;#什么是单调栈&quot; class=&quot;headerlink&quot; title=&quot;什么是单调栈&quot;&gt;&lt;/a&gt;什么是单调栈&lt;/h2&gt;&lt;p&gt;单调栈是满足单调性的栈结构。分为单调递增栈和单调递减栈。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://Mkozex.github.io/categories/Algorithm/"/>
    
    
      <category term="数据结构" scheme="http://Mkozex.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="单调栈" scheme="http://Mkozex.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>「ZROJ」造数据-前缀和</title>
    <link href="http://Mkozex.github.io/2019/11/10/%E3%80%8CZROJ%E3%80%8D%E9%80%A0%E6%95%B0%E6%8D%AE/"/>
    <id>http://Mkozex.github.io/2019/11/10/「ZROJ」造数据/</id>
    <published>2019-11-10T03:37:47.000Z</published>
    <updated>2020-02-11T03:19:53.730Z</updated>
    
    <content type="html"><![CDATA[<p>比赛已经开始了，可是鸽王小W还没有造好数据。</p><p>他现在在赶造数据。数据是一个 $n\times m \ (1\le n, m\le 1000)$ 的矩阵 $a_{i, j}$，现在小Y对这个矩阵很感兴趣。小Y想知道，如果定义函数<br>$$<br>f(x_l,x_r,y_l,y_r)=\sum_{i=x_l}^{x_r} \sum_{j=y_l}^{y_r} a_{i,j}<br>$$<br>那么对于给定的 $X_l, X_r, Y_l, Y_r$ ,问<br>$$<br>\sum_{1 \le a \le b \le n, X_l \le b-a+1 \le X_r} \ \ \ \ \ \sum_{1 \le c \le d \le m, Y_l \le d-c+1 \le Y_r} f(a, b, c, d)<br>$$<br>即询问包含行的个数在 $X_l$ 到 $X_r$ 之间，包含列的个数在 $Y_l$ 到 $Y_r$ 之间的所有子矩阵的元素和的和。</p><p>小Y一共会给出 $q$ 组询问，他想让你帮他快速回答这些询问。由于答案可能很大，小Y只要你输出答案对 $998244353$ 取模之后的结果。</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>显然是前缀和，但如果只记一个前缀和，复杂度是 $n^4 q$，无法通过本题。</p><p>因此，我们可以考虑线预处理所有长为 $l$ ，宽为 $r$ 的答案，即求出：<br>$$<br>b_{l, r} = \sum_{i = 1} ^{n - l + 1}\sum_{j = 1} ^{m - r + 1} f(i, i + r - 1, j, j + c - 1)<br>$$<br>即<br>$$<br>\begin{align}<br>b_{l, r} &amp; = \sum_{i = 1} ^{n - l + 1}\sum_{j = 1} ^{m - l + 1} s_{i + l - 1, j + r - 1} - s_{i - 1, j + r - 1} - s_{i + l - 1, j - 1} + s_{i - 1, j - 1}\newline<br>&amp; = \sum_{i = l} ^{n}\sum_{j = r}^m s_{i, j} + \sum_{i = l} ^{n - l + 1}\sum_{j = r}^m s_{i, j} + \sum_{i = l} ^{n}\sum_{j = r}^{m - r + 1} s_{i, j} + \sum_{i = l} ^{n - l + 1}\sum_{j = r}^{m - r + 1} s_{i, j}<br>\end{align}<br>$$<br>记一个前缀和就可以 $O(1)$ 求出 $b_{i, j}$ 了。</p><p>于是，询问就变成了求<br>$$<br>\sum_{i = X_l} ^{X_r} \sum_{j = Y_l} ^{Y_r}b_{i, j}<br>$$<br>再做一遍前缀和即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (int i = a; i &lt;= b; ++i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">int</span> a[N][N], s[N][N], sa[N][N], sb[N][N], sc[N][N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">a += b;</span><br><span class="line"><span class="keyword">if</span> (a &lt; p) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a - p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">a -= b;</span><br><span class="line"><span class="keyword">if</span> (a &gt;= <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a + p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> a[][N], <span class="keyword">int</span> xl, <span class="keyword">int</span> xr, <span class="keyword">int</span> yl, <span class="keyword">int</span> yr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> add( sub( sub(a[xr][yr], a[xl - <span class="number">1</span>][yr]), a[xr][yl - <span class="number">1</span>]), a[xl - <span class="number">1</span>][yl - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">rep(j, <span class="number">1</span>, m) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">rep(j, <span class="number">1</span>, m) </span><br><span class="line">s[i][j] = add( sub( add(s[i - <span class="number">1</span>][j], s[i][j - <span class="number">1</span>]), s[i - <span class="number">1</span>][j - <span class="number">1</span>]), a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">rep(j, <span class="number">1</span>, m) </span><br><span class="line">sa[i][j] = add( sub( add(sa[i - <span class="number">1</span>][j], sa[i][j - <span class="number">1</span>]), sa[i - <span class="number">1</span>][j - <span class="number">1</span>]), s[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">rep(j, <span class="number">1</span>, m)</span><br><span class="line">sb[i][j] = add( sub (sub (get(sa, i, n, j, m), get(sa, <span class="number">0</span>, n - i, j, m)), get(sa, i, n, <span class="number">0</span>, m - j)), get(sa, <span class="number">0</span>, n - i, <span class="number">0</span>, m - j));</span><br><span class="line">&#125;</span><br><span class="line">rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">rep(j, <span class="number">1</span>, m)</span><br><span class="line">sc[i][j] = add( sub( add(sc[i - <span class="number">1</span>][j], sc[i][j - <span class="number">1</span>]), sc[i - <span class="number">1</span>][j - <span class="number">1</span>]), sb[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> xl, xr, yl, yr;</span><br><span class="line">rep(i, <span class="number">1</span>, q) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;xl, &amp;xr, &amp;yl, &amp;yr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, get(sc, xl, xr, yl, yr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比赛已经开始了，可是鸽王小W还没有造好数据。&lt;/p&gt;
&lt;p&gt;他现在在赶造数据。数据是一个 $n\times m \ (1\le n, m\le 1000)$ 的矩阵 $a_{i, j}$，现在小Y对这个矩阵很感兴趣。小Y想知道，如果定义函数&lt;br&gt;$$&lt;br&gt;f(x_l,x_r,y_l,y_r)=\sum_{i=x_l}^{x_r} \sum_{j=y_l}^{y_r} a_{i,j}&lt;br&gt;$$&lt;br&gt;那么对于给定的 $X_l, X_r, Y_l, Y_r$ ,问&lt;br&gt;$$&lt;br&gt;\sum_{1 \le a \le b \le n, X_l \le b-a+1 \le X_r} \ \ \ \ \ \sum_{1 \le c \le d \le m, Y_l \le d-c+1 \le Y_r} f(a, b, c, d)&lt;br&gt;$$&lt;br&gt;即询问包含行的个数在 $X_l$ 到 $X_r$ 之间，包含列的个数在 $Y_l$ 到 $Y_r$ 之间的所有子矩阵的元素和的和。&lt;/p&gt;
&lt;p&gt;小Y一共会给出 $q$ 组询问，他想让你帮他快速回答这些询问。由于答案可能很大，小Y只要你输出答案对 $998244353$ 取模之后的结果。&lt;/p&gt;
    
    </summary>
    
      <category term="Solution" scheme="http://Mkozex.github.io/categories/Solution/"/>
    
    
      <category term="前缀和" scheme="http://Mkozex.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="ZROJ" scheme="http://Mkozex.github.io/tags/ZROJ/"/>
    
  </entry>
  
  <entry>
    <title>「NOIP2015」信息传递-并查集+最小环</title>
    <link href="http://Mkozex.github.io/2019/11/09/%E3%80%8CNOIP2015%E3%80%8D%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92/"/>
    <id>http://Mkozex.github.io/2019/11/09/「NOIP2015」信息传递/</id>
    <published>2019-11-09T13:56:01.000Z</published>
    <updated>2020-03-07T03:31:08.878Z</updated>
    
    <content type="html"><![CDATA[<p>有 $n$ 个同学（编号为 $1$ 到 $n$ ）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为 $i$ 的同学的信息传递对象是编号为 $T_i$ 的同学。</p><p>游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息， 但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自 己的生日时，游戏结束。请问该游戏一共可以进行几轮？</p><a id="more"></a><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://loj.ac/submission/669048" target="_blank" rel="noopener">LOJ 2421</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一句话题解就是<strong>并查集求最小环</strong>。</p><p>如果 $A$ 将信息传递给 $B$，那么就将 $A$ 与 $B$ 连起来，同时进行更新： $d_A = d_B + 1$ 。</p><p>建好图之后可以发现，游戏结束的轮数等于图中最小环的长度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Minx = <span class="number">0x7777777</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], d[N], n, minn = Minx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] != x) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = fa[x];</span><br><span class="line">        fa[x] = find(fa[x]);</span><br><span class="line">        d[x] += d[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = find(a), y = find(b);</span><br><span class="line">    <span class="keyword">if</span> (x != y)</span><br><span class="line">        fa[x] = y, d[a] = d[b] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        minn = min(minn, d[a] + d[b] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t), search(i, t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, minn);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有 $n$ 个同学（编号为 $1$ 到 $n$ ）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为 $i$ 的同学的信息传递对象是编号为 $T_i$ 的同学。&lt;/p&gt;
&lt;p&gt;游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息， 但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自 己的生日时，游戏结束。请问该游戏一共可以进行几轮？&lt;/p&gt;
    
    </summary>
    
      <category term="Solution" scheme="http://Mkozex.github.io/categories/Solution/"/>
    
    
      <category term="图论" scheme="http://Mkozex.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="LOJ" scheme="http://Mkozex.github.io/tags/LOJ/"/>
    
      <category term="NOIP" scheme="http://Mkozex.github.io/tags/NOIP/"/>
    
      <category term="并查集" scheme="http://Mkozex.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>简单DP做题记录</title>
    <link href="http://Mkozex.github.io/2019/11/06/DP%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://Mkozex.github.io/2019/11/06/DP做题记录/</id>
    <published>2019-11-06T12:35:01.000Z</published>
    <updated>2020-03-07T03:34:57.523Z</updated>
    
    <content type="html"><![CDATA[<p>因为自己的dp太弱，于是有了这篇文章 $\mathcal{Q\omega Q}$ 。都是一些很sb的题目。</p><a id="more"></a><h3 id="开心的金明"><a href="#开心的金明" class="headerlink" title="开心的金明"></a>开心的金明</h3><p> <a href="https://www.luogu.org/problem/P1060" target="_blank" rel="noopener">[Luogu P1060]</a></p><p>将价格看成体积，价格与重要度相乘的值看成物品的价值，然后就是01背包了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 30010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, v[N], w[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;v[i], &amp;w[i]), w[i] *= v[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= v[i]; --j)</span><br><span class="line">f[j] = max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, f[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="货币系统"><a href="#货币系统" class="headerlink" title="货币系统"></a>货币系统</h3><p><a href="https://www.luogu.org/problem/P5020" target="_blank" rel="noopener">[Luogu P5020]</a></p><p>对于一种货币系统，例如 $(4, [3, 19, 10, 6])$ ，我们发现 $19 = 10 + 3 + 3 + 3\ ,\ 6 = 3 + 3$，于是这个货币系统与 $(2, [3, 10])$ 对应。因此我们发现，当系统中有一种货币可以表示为另外几种货币的和时，那这种货币就没什么用了。于是就是一个像背包的东西。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 150000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, a[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), f[a[i]] = <span class="number">2</span>;</span><br><span class="line">sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[n]; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) </span><br><span class="line">                <span class="keyword">if</span> (i + a[j] &lt;= a[n]) </span><br><span class="line">                    f[i + a[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;    </span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[n]; ++i) <span class="keyword">if</span> (f[i] == <span class="number">2</span>) ans++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传纸条"><a href="#传纸条" class="headerlink" title="传纸条"></a>传纸条</h3><p><a href="https://www.luogu.org/problem/P1006" target="_blank" rel="noopener">[Luogu P1006]</a></p><p>根据题意，我们可以很容易的写出其四维的转移方程：<br>$$<br>f_{i, j, k, l} = \max ( f_{i, j-1, k-1, l},f_{i, j-1, k, l-1},f_{i-1, j, k-1, l},f_{i-1, j, k, l-1} ) + a_{i, j} + a_{k, l}<br>$$<br>（其中 $f_{i, j, k, l}$ 表示的是从 $(i, j)$ 到 $(k, l)$的最大好感度。）</p><p><del>这样就可以AC了</del> 考虑如何化简，可以发现对于 $i, j, k, l$ 始终有 $i + j = k + l$ ，于是可将方程减少一维。</p><p>貌似可以再优化到二维， $\mathcal{Q\omega Q}$ 不会。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, a[N][N], f[N][N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m - <span class="number">1</span>; ++i) </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k) &#123;</span><br><span class="line"><span class="keyword">if</span> (i - k &lt; <span class="number">0</span> || i - j &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">f[i][j][k] = max(max(f[i - <span class="number">1</span>][j][k], f[i - <span class="number">1</span>][j - <span class="number">1</span>][k]),</span><br><span class="line">                                 max(f[i - <span class="number">1</span>][j][k - <span class="number">1</span>], f[i - <span class="number">1</span>][j - <span class="number">1</span>][k - <span class="number">1</span>])) </span><br><span class="line">                             + a[k][i - k + <span class="number">1</span>] + a[j][i - j + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (j == k) f[i][j][k] -= a[j][i - j + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, f[n + m - <span class="number">1</span>][m][m]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="守望者的逃离"><a href="#守望者的逃离" class="headerlink" title="守望者的逃离"></a>守望者的逃离</h3><p><a href="https://www.luogu.org/problem/P1095" target="_blank" rel="noopener">[Luogu P1095]</a></p><p>这道题就是能用闪烁时立刻用，如果在某一时刻走路比只闪烁更优，那就选用走路。</p><p>（其实这道题连数组都不用，但为了让它看起来像个dp，我就用了）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, s, t, f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;m, &amp;s, &amp;t);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) <span class="keyword">if</span> (m &gt;= <span class="number">10</span>) f[i] = f[i - <span class="number">1</span>] + <span class="number">60</span>, m -= <span class="number">10</span>;</span><br><span class="line"><span class="keyword">else</span> f[i] = f[i - <span class="number">1</span>], m += <span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">f[i] = max(f[i], f[i - <span class="number">1</span>] + <span class="number">17</span>);</span><br><span class="line"><span class="keyword">if</span> (f[i] &gt;= s) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Yes\n%d"</span>, i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"No\n%d"</span>, f[t]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="摆花"><a href="#摆花" class="headerlink" title="摆花"></a>摆花</h3><p><a href="https://www.luogu.org/problem/P1077" target="_blank" rel="noopener">[Luogu P1077]</a></p><p>由题意可以看出这是个很显然的dp，我们可以设 $f_{i, j}$ 为用了 $i$  种花摆了 $j$ 盆时的方案数。那么可以由题意得知动态转移方程为：<br>$$<br>f_{i, j} = \sum_{k = 0} ^{a_i} f_{i - 1, j - k}<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(j, a[i]); ++k) f[i][j] = (f[i][j] + f[i - <span class="number">1</span>][j - k]) % mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, f[n][m]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Crested-Ibis-vs-Monster"><a href="#Crested-Ibis-vs-Monster" class="headerlink" title="Crested Ibis vs Monster"></a>Crested Ibis vs Monster</h3><p><a href="https://atcoder.jp/contests/abc153/tasks/abc153_e" target="_blank" rel="noopener">ABC153 E</a></p><p>经典的01背包问题，可以选择开大空间一次解决怪兽血量低于 $0$ 的问题，也可以枚举最后一击以及怪兽血量并取最小值（我用的是这种）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h, n, a[N], b[N], dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;h, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a[i], &amp;b[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= h; ++i) dp[i] = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = a[i]; j &lt;= h; ++j) dp[j] = min(dp[j], dp[j - a[i]] + b[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = h; j &gt;= max(<span class="number">0</span>, h - a[i]); --j) &#123;</span><br><span class="line">ans = min(ans, dp[j] + b[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为自己的dp太弱，于是有了这篇文章 $\mathcal{Q\omega Q}$ 。都是一些很sb的题目。&lt;/p&gt;
    
    </summary>
    
      <category term="Solution" scheme="http://Mkozex.github.io/categories/Solution/"/>
    
    
      <category term="DP" scheme="http://Mkozex.github.io/tags/DP/"/>
    
      <category term="NOIP" scheme="http://Mkozex.github.io/tags/NOIP/"/>
    
      <category term="Atcoder" scheme="http://Mkozex.github.io/tags/Atcoder/"/>
    
      <category term="Luogu" scheme="http://Mkozex.github.io/tags/Luogu/"/>
    
  </entry>
  
  <entry>
    <title>生成函数(1)-基本法则及运算</title>
    <link href="http://Mkozex.github.io/2019/10/12/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%EF%BC%881%EF%BC%89-%E5%9F%BA%E6%9C%AC%E6%B3%95%E5%88%99%E5%8F%8A%E8%BF%90%E7%AE%97/"/>
    <id>http://Mkozex.github.io/2019/10/12/生成函数（1）-基本法则及运算/</id>
    <published>2019-10-12T14:21:57.000Z</published>
    <updated>2020-03-22T11:42:02.869Z</updated>
    
    <content type="html"><![CDATA[<p>下面的一些文章会逐步介绍生成函数（边学边写）。</p><a id="more"></a><h2 id="定义以及记号"><a href="#定义以及记号" class="headerlink" title="定义以及记号"></a>定义以及记号</h2><p>对于一个无限序列$\ \left \langle a_0, a_1, a_2,\cdots \right \rangle\ $，我们可以很方便地将其表示成一个辅助变量$\ z\ $的幂级数。<br>$$<br>G(z) = g_0 + g_1z + g_2z^2 + \cdots = \sum_{k\ge 0} g_k z^k \tag{1}<br>$$<br>那么我们将$\ G(z)\ $称为该序列的生成函数。$\ G(z)\ $中$\ z^n\ $的系数$\ g_n\ $常记为$\ [z^n]G(z)\ $。</p><p>我们可以将$\ (1.1)\ $中的$\ n\ $拓展成整数使得运算更加方便。我们可以直接令$\ g_{-1} = g_{-2} = \cdots = 0 \ $来做到这一点。</p><p>当我们处理生成函数时，会出现两种“封闭形式”。对$\ G(z)\ $，我们可能会有一个用$\ z\ $表示的封闭形式；对$\ \left \langle g_n \right \rangle\ $，我们可能会有一个用$\ n\ $表示的封闭形式（或称通项公式）。上下文会指明是哪一种。</p><p>并且，在本篇以及其他几篇中，我们不对收敛性展开任何讨论。因为我们可以严格地证明生成函数所做的每一个运算都能作为形式幂级数上的运算，这种运算时合法的，甚至是在技术不收敛时也是如此。</p><h2 id="运算法则"><a href="#运算法则" class="headerlink" title="运算法则"></a>运算法则</h2><p>在下面的文章中，除非有其他的规定，我们都假设$\ F(z)\ $和$\ G(z)\ $是数列$\ \left \langle   f_n \right \rangle\ $和$\ \left \langle g_n \right \rangle\ $的生成函数，并且对于任何的$\ n &lt; 0\ $，$\ f_n = g_n = 0\ $。</p><h3 id="相加"><a href="#相加" class="headerlink" title="相加"></a>相加</h3><p>$$<br>\begin{align}<br>\alpha F(z) + \beta G(z) &amp;= \alpha \sum_{n}f_n z^n + \beta \sum_{n} g_n z^n\newline<br>&amp;= \sum_{n} (\alpha f_n + \beta g_n)z^n \tag{2}<br>\end{align}<br>$$</p><h3 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h3><ul><li><p>左移：</p><p>$$<br>z^m G(z) = \sum_{n} g_n z^{n + m} = \sum_{n}g_{n - m} z^n\ , \ m\in \mathbb{N}^* \tag{3}<br>$$</p></li><li><p>右移：<br>$$<br>\frac{G(z) - g_0 - g _ 1z - \cdots - g_{m - 1} z ^ {m - 1}}{z^m} = \sum_{n \ge m} g_n z^{n - m} = \sum_{n \ge 0} g_{n - m} z ^ n \tag{4}<br>$$</p></li></ul><p>注意：此时$\ g_{-1} \sim g_{-m} \ne 0\ $，因此我们不能将最后那个和式扩大到对所有$ \ n\ $求和。</p><h3 id="改换变量"><a href="#改换变量" class="headerlink" title="改换变量"></a>改换变量</h3><p>$$<br>G(cz) = \sum_{n} g_n (cz)^n = \sum_{n}g_n c^nz^n \tag{5}<br>$$</p><h3 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h3><p>$$<br>G’(z) = g_1 + 2g_2z + 3g_3z^2 + \cdots =\sum_{n} (n + 1) g_{n + 1}z^n \tag{6}<br>$$</p><p>或者将其向右移一位：<br>$$<br>zG’(z) = \sum_{n} ng_n z_n \tag{7}<br>$$</p><h3 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h3><p>$$<br>\int_{0} ^{z} G(t)\mathrm{d}t = g_0 z + \frac{1}{2}g_1z^2 + \frac{1}{3}g_2 ^3 + \cdots = \sum_{n \ge 1} \frac{1}{n}g_{n - 1} z^n \tag{8}<br>$$</p><h3 id="相乘"><a href="#相乘" class="headerlink" title="相乘"></a>相乘</h3><p>$$<br>\begin{align}<br>F(z)G(z) &amp;= (f_0 + f_1z + f_2z^2 + \cdots) (g_0 + g_1z + g_2z^2 + \cdots)\newline<br>&amp;= f_0g_0 + (f_0g_1 + f_1g_0)z + (f_0g_2 + f_1g_1 + f_2g_0)z^2 + \cdots\newline<br>&amp;= \sum_{n}(\sum_{k}f_kg_{n - k})z^n \tag{9}<br>\end{align}<br>$$</p><p>这里$\ z^n\ $的系数$\ \sum_{k}f_kg_{n - k}\ $也是后面会说到的卷积，我们会对这个东西展开较为深入的研究。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面的一些文章会逐步介绍生成函数（边学边写）。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://Mkozex.github.io/categories/Algorithm/"/>
    
    
      <category term="Math" scheme="http://Mkozex.github.io/tags/Math/"/>
    
      <category term="生成函数" scheme="http://Mkozex.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>「BZOJ1257」余数之和-数论分块</title>
    <link href="http://Mkozex.github.io/2019/08/09/%E3%80%8CBZOJ1257%E3%80%8D%E4%BD%99%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://Mkozex.github.io/2019/08/09/「BZOJ1257」余数之和/</id>
    <published>2019-08-09T11:21:57.000Z</published>
    <updated>2020-02-25T14:44:06.456Z</updated>
    
    <content type="html"><![CDATA[<p>给定$\ n, k\ $，计算$\ \sum_{i = 1} ^{n}k \bmod i\ $。</p><a id="more"></a><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1257" target="_blank" rel="noopener">BZOJ 1257</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于<br>$$<br>k \bmod i = k - i  \left\lfloor\frac{k}{i}\right\rfloor<br>$$<br>于是可以可以将原题的式子修改成<br>$$<br>\sum_{i = 1}^{n} {k - i  \left\lfloor\frac{k}{i}\right\rfloor}\<br>\Rightarrow n  k - \sum_{i = 1}^{n} {i  \left\lfloor\frac{k}{i}\right\rfloor}\<br>$$<br>于是就可以很容易的看出是很显然的数论分块，$\ i\ $是递增的，而$\ k/i\ $在一段范围内是不会变化的，那么就是一个等差数列啦。因此，每次求出这一段范围，然后计算等差数列即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = n * k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (k / i) j = min(n, k / (k / i));</span><br><span class="line"><span class="keyword">else</span> j = n;</span><br><span class="line">ans -= (k / i) * (j - i + <span class="number">1</span>) * (i + j) / <span class="number">2</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定$\ n, k\ $，计算$\ \sum_{i = 1} ^{n}k \bmod i\ $。&lt;/p&gt;
    
    </summary>
    
      <category term="Solution" scheme="http://Mkozex.github.io/categories/Solution/"/>
    
    
      <category term="数论" scheme="http://Mkozex.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="Math" scheme="http://Mkozex.github.io/tags/Math/"/>
    
      <category term="BZOJ" scheme="http://Mkozex.github.io/tags/BZOJ/"/>
    
      <category term="数论分块" scheme="http://Mkozex.github.io/tags/%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>树状数组</title>
    <link href="http://Mkozex.github.io/2019/07/24/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <id>http://Mkozex.github.io/2019/07/24/树状数组/</id>
    <published>2019-07-24T13:53:31.000Z</published>
    <updated>2020-03-05T03:54:22.893Z</updated>
    
    <content type="html"><![CDATA[<p>最近，学习了树状数组这种十分常用的数据结构，真是有趣呢。</p><p>树状数组可以在常数很小的 $O(n\log n)$ 复杂度内实现单点加法以及区间求和（区间加也行？）。</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>为了了解树状数组的工作原理，可以看下面这一张图</p><p>（第一行为数组 $a$ ）。</p><p><img src="https://s2.ax1x.com/2019/07/26/enwdzR.png" alt="enwdzR.png"></p><p>我们不妨设那些参差不齐的方块为数组$ \ t \ $，并且设那些从中，我们可以看出：</p><p>$t[2]$ 掌控着$a[1],a[2]$；</p><p>$t[4]$ 掌控着$a[1],a[2], a[3], a[4]$；</p><p>$t[6]$ 掌控着$a[5],a[6]$；</p><p> $t[8]$ 掌控着$a[1-8]$。</p><p>所以如果我们要计算区间和，就可以不用一个一个去加，可以利用这幅图所表示的倍增的思来进行复杂度的优化。</p><h2 id="入门操作"><a href="#入门操作" class="headerlink" title="入门操作"></a>入门操作</h2><p>既然有了原理，那么就是该如何操作的问题了，但怎么知道$\ t_i\ $管理了$\ a \ $的个数呢？</p><p>于是，我们就引入了函数<code>lowbit(x)</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录一共掌控了几个a</span></span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>x &amp; -x</code>是利用了计算机内部的编码特性，即补码。因此，我们可以通过<code>lowbit(x)</code>计算出$\ t\ $掌控的个数。</p><h2 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h2><p>既然有了<code>lowbit(x)</code>函数，那么单点修改就很轻松了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += lowbit(x)) t[x] += k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>于是基于差分的思想，我们可以得出<strong>区间修改</strong>的代码：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    updata(l, k);</span><br><span class="line">    updata(r + <span class="number">1</span>, -k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>因为树状数组的性质，我们每次查询时不用单个的枚举，只需每次从需要查询的<code>x</code>中减去<code>lowbit(x)</code>即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= lowbit(x)) ans += t[x];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>于是同样的，基于差分的思想，我们可以得出<strong>区间查询</strong>的代码。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> query(r) - query(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="入门后的操作"><a href="#入门后的操作" class="headerlink" title="入门后的操作"></a>入门后的操作</h2><h3 id="区间加区间求和"><a href="#区间加区间求和" class="headerlink" title="区间加区间求和"></a>区间加区间求和</h3><p>我们当然可以用接下来的线段树，但因为现在讲的是树状数组，所以就用树状数组来解决吧，既然用一个不行，那就用两个！</p><p>首先，因为区间和可以用两个前缀和得到，所以我们不妨对$\ a\ $的一个前缀$\ r\ $求和，即$\sum_{i=1}^ra_i$进行考虑，不妨设$\ a\ $的差分数组为$\ b\ $</p><p>进行推导<br>$$<br>\sum_{i=1}^ra_i<br>$$</p><p>$$<br>=\sum_{i=1}^r\sum_{j=1}^ib_i<br>$$</p><p>$$<br>=\sum_{i=1}^{r}b_i\times(r-i+1)<br>$$</p><p>$$<br>=\sum_{i=1}^rb_i\times(r+1)-\sum_{i=1}^rb_i\times i<br>$$</p><p>于是，我们只需用两个树状数组分别维护$\ \sum b_i\ $和$ \ \sum i \times b_i\ $即可。</p><p>代码在这呢：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t1[maxn], t2[maxn], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = k * x;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x +=lowbit(x)) t1[x] += k, t2[x] += h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= lowbit(x)) ans += t[x];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    updata(l, k), updata(r + <span class="number">1</span>, -v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (r + <span class="number">1l</span>l) * (query(t1, r) - query(t1, l - <span class="number">1</span>)) - </span><br><span class="line">           (query(t2, r) - query(t2, l - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>另外，树状数组还有其他一些神奇的小trick，<strong>然鹅我不会</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近，学习了树状数组这种十分常用的数据结构，真是有趣呢。&lt;/p&gt;
&lt;p&gt;树状数组可以在常数很小的 $O(n\log n)$ 复杂度内实现单点加法以及区间求和（区间加也行？）。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://Mkozex.github.io/categories/Algorithm/"/>
    
    
      <category term="学习笔记" scheme="http://Mkozex.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据结构" scheme="http://Mkozex.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树状数组" scheme="http://Mkozex.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>「BZOJ3884」上帝与集合的正确用法-扩展欧拉定理</title>
    <link href="http://Mkozex.github.io/2019/07/20/%E3%80%8CBZOJ3884%E3%80%8D%E4%B8%8A%E5%B8%9D%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95/"/>
    <id>http://Mkozex.github.io/2019/07/20/「BZOJ3884」上帝与集合的正确用法/</id>
    <published>2019-07-20T10:20:47.000Z</published>
    <updated>2019-10-10T14:03:34.257Z</updated>
    
    <content type="html"><![CDATA[<p>这道题要求的是$\ 2^{2^{2^{\cdots}}}\bmod p$。</p><a id="more"></a><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3884" target="_blank" rel="noopener">BZOJ 3884</a></p><p><a href="https://www.luogu.org/problemnew/show/P4139" target="_blank" rel="noopener">Luogu P4139</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>可以进行如下推导<br>$$<br>f(p)=2^{2^{2^{\cdots}}\bmod \varphi(p)+ \varphi(p)}\pmod p<br>$$<br>$$<br>=2^{f(\varphi(p))+ \varphi(p)}\pmod p<br>$$</p><p>于是就有了$\ f\ $的递推式，<del>可以直接递归计算</del></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            res /= i, res *= i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x ^ <span class="number">1</span>) res /= x, res *= x - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(ll a, <span class="keyword">int</span> b, <span class="keyword">int</span> MOD)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = (ans * a) % MOD;</span><br><span class="line">        a = (a * a) % MOD;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, solve(phi(p)) + phi(p), p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll T, a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h4><p>这道题有一个十分神奇的地方，就是在<code>BZOJ</code>中，<strong>先预处理</strong>出欧拉函数各值程序会<code>TLE</code>，<strong>但是</strong>在<code>Luogu</code>中，<strong>等到执行后再</strong>求单个欧拉函数反而会<code>TLE</code>，好神奇呐$\mathcal{Q \omega Q}$。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题要求的是$\ 2^{2^{2^{\cdots}}}\bmod p$。&lt;/p&gt;
    
    </summary>
    
      <category term="Solution" scheme="http://Mkozex.github.io/categories/Solution/"/>
    
    
      <category term="Luogu" scheme="http://Mkozex.github.io/tags/Luogu/"/>
    
      <category term="数论" scheme="http://Mkozex.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="Math" scheme="http://Mkozex.github.io/tags/Math/"/>
    
      <category term="欧拉定理" scheme="http://Mkozex.github.io/tags/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"/>
    
      <category term="扩展欧拉定理" scheme="http://Mkozex.github.io/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"/>
    
      <category term="BZOJ" scheme="http://Mkozex.github.io/tags/BZOJ/"/>
    
  </entry>
  
  <entry>
    <title>「SDOI2010」古代猪文-CRT+Lucas定理</title>
    <link href="http://Mkozex.github.io/2019/07/20/%E3%80%8CSDOI2010%E3%80%8D%E5%8F%A4%E4%BB%A3%E7%8C%AA%E6%96%87/"/>
    <id>http://Mkozex.github.io/2019/07/20/「SDOI2010」古代猪文/</id>
    <published>2019-07-20T08:30:47.000Z</published>
    <updated>2020-02-25T14:44:19.536Z</updated>
    
    <content type="html"><![CDATA[<p>这道题要让我们求的是$\ G^{\sum_{d|m}C^d_n} \bmod 999911659\ $。</p><a id="more"></a><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.luogu.org/problemnew/show/P2480" target="_blank" rel="noopener">Luogu P2480</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>因为，根据欧拉定理推论<br>$$<br>\ G^{\sum_{d|m}C^d_n} \bmod 999911659=G^{\sum_{d|m}C^d_n \bmod 999911658}<br>$$<br>并且，我们有<br>$$<br>999911658=2\times 3\times 4679 \times 35617<br>$$<br>然后，我们就可以用 $\mathrm{Lucas}$ 定理将 $C^d_n$ 算出来，并且计算出 $\sum_{d|n}C^d_n$ 对 $ 2,3,4679， 35617 $ 取模的结果，记为 $ a_1, a_2, a_3, a_4 $ 。</p><p>之后，我们用中国剩余定理求解一下方程组：<br>$$<br>x\equiv a_1 \pmod 2<br>$$</p><p>$$<br>x\equiv a_2 \pmod 3<br>$$</p><p>$$<br>\quad x\equiv a_3 \pmod {4679}<br>$$</p><p>$$<br>\quad \ \ x\equiv a_4 \pmod {35617}<br>$$</p><p>最后，用快速幂求一下$\ G^x\ $即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 999911658</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll n, g, v, fac[<span class="number">50002</span>], a[<span class="number">5</span>], b[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4679</span>, <span class="number">35617</span>&#125;, D[<span class="number">5</span>], N[<span class="number">5</span>], y[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">pow</span><span class="params">(ll a, ll b, ll MOD)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = (ans * a) % MOD;</span><br><span class="line">        a = (a * a) % MOD;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= p; ++i) fac[i] = fac[i - <span class="number">1</span>] * i % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> frac[n] * <span class="built_in">pow</span>(fac[m], p - <span class="number">2</span>, p) % p * <span class="built_in">pow</span>(fac[n - m], p - <span class="number">2</span>, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Lucas</span><span class="params">(ll n, ll m, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Lucas(n / p, m / p, p) * C(n % p, m % p, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">        v = (v + a[i] * (M / b[i]) % M * <span class="built_in">pow</span>(M / b[i], b[i] - <span class="number">2</span>, b[i])) % M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;g);</span><br><span class="line">    <span class="keyword">if</span> (g % (M + <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        F(b[i]);</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">1</span>; j * j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % j == <span class="number">0</span>) &#123;</span><br><span class="line">                a[i] = (a[i] + Lucas(n, j, b[i])) % b[i];</span><br><span class="line">                <span class="keyword">if</span> (j * j != n) a[i] = (a[i] + Lucas(n, n / j, b[i])) % b[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    crt();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, <span class="built_in">pow</span>(g, v, M + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题要让我们求的是$\ G^{\sum_{d|m}C^d_n} \bmod 999911659\ $。&lt;/p&gt;
    
    </summary>
    
      <category term="Solution" scheme="http://Mkozex.github.io/categories/Solution/"/>
    
    
      <category term="Luogu" scheme="http://Mkozex.github.io/tags/Luogu/"/>
    
      <category term="数论" scheme="http://Mkozex.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="Math" scheme="http://Mkozex.github.io/tags/Math/"/>
    
      <category term="欧拉定理" scheme="http://Mkozex.github.io/tags/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"/>
    
      <category term="Lucas定理" scheme="http://Mkozex.github.io/tags/Lucas%E5%AE%9A%E7%90%86/"/>
    
      <category term="CRT" scheme="http://Mkozex.github.io/tags/CRT/"/>
    
  </entry>
  
  <entry>
    <title>Miller-Rabin素性检测</title>
    <link href="http://Mkozex.github.io/2019/06/08/Miller-Rabin%E7%B4%A0%E6%80%A7%E6%A3%80%E6%B5%8B/"/>
    <id>http://Mkozex.github.io/2019/06/08/Miller-Rabin素性检测/</id>
    <published>2019-06-08T05:01:32.000Z</published>
    <updated>2019-10-10T14:04:11.042Z</updated>
    
    <content type="html"><![CDATA[<p>我们常用的单个素数检测复杂度为$\  O(\sqrt{n})\ $，当$\ n \ $很大时，这种方法就不适用了，于是我们就有了$\mathrm{Miller-Rabin}$素数判定方法，这种判定的复杂度可以降至$\ O(k\log ^3 n)$（其中$\ k \ $时测试的轮数）</p><a id="more"></a><h2 id="关于费马小定理"><a href="#关于费马小定理" class="headerlink" title="关于费马小定理"></a>关于费马小定理</h2><p>对于$\mathrm{Miller-Rabin}$算法， 有人可能会说，直接用费马小定理啊。<br>确实，我们可以根据费马小定理得出一种检验素数的思路：<br>不断的选取$\ [2,n-1]\ $中的基$\ a \ $，并检测是否都有$\ a^{n-1}\equiv 1 \pmod n$<br>而很遗憾的是，费马小定理的逆定理并不成立，也就是，存在合数$\ n \ $使得对于$\ [2,n-1]\ $中的每一个数，$\ a^{n-1}\equiv 1 \pmod n$均成立。由此，我们引出了卡迈克尔数$(\mathrm{Carmichael\ Number})$</p><h2 id="卡迈克尔数"><a href="#卡迈克尔数" class="headerlink" title="卡迈克尔数"></a>卡迈克尔数</h2><p>卡迈克尔数$(\mathrm{Carmichael\ Number})$指的是对于$\ [2,n-1]\ $中的每一个数，$\ a^{n-1}\equiv 1 \pmod n$均成立的合数$\ n \ $。<br>比如$\ 341\ $就是一个卡迈克尔数。<br>而且我们可以知道：如果$\ n \ $是一个卡迈克尔数，则$\ m=2^n+1\ $也一定是一个卡迈克尔数，因此，卡迈克尔数的个数是无穷的。</p><h2 id="二次探测定理"><a href="#二次探测定理" class="headerlink" title="二次探测定理"></a>二次探测定理</h2><p>二次探测定理指的是：如果$\ p \ $是一个奇素数，则$\ x^2\equiv 1 \pmod p\ $的解为$\ x=1\ $或者$\ x=p-1 \pmod p\ $</p><h2 id="mathrm-Miller-Rabin-算法"><a href="#mathrm-Miller-Rabin-算法" class="headerlink" title="$\mathrm{Miller-Rabin}\ $算法"></a>$\mathrm{Miller-Rabin}\ $算法</h2><p>有了那么多的东西，所以我们不妨将费马小定理与二次探测定理结合起来使用，一起来对付那些卡迈克尔数：<br>对于$\ n \ $，我们可以将$\ n-1\ $分解为$\ n-1=u\times 2^t\ $，然后不断地对$\ u\ $进行平方，如果发现了非平凡平方根，则可判定$\ n\ $不是素数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MR</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> n == <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> a = n - <span class="number">1</span>, b = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (a % <span class="number">2</span> == <span class="number">0</span>) a /= <span class="number">2</span>, ++b;</span><br><span class="line">  <span class="comment">// k为测试次数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= k; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = rand() % (n - <span class="number">2</span>) + <span class="number">2</span>, v = <span class="built_in">pow</span>(x, a, n);</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">1</span> || v == n - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; b; ++j) &#123;</span><br><span class="line">      v = (<span class="keyword">long</span> <span class="keyword">long</span>)v * v % n;</span><br><span class="line">      <span class="keyword">if</span> (v == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= b) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们常用的单个素数检测复杂度为$\  O(\sqrt{n})\ $，当$\ n \ $很大时，这种方法就不适用了，于是我们就有了$\mathrm{Miller-Rabin}$素数判定方法，这种判定的复杂度可以降至$\ O(k\log ^3 n)$（其中$\ k \ $时测试的轮数）&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://Mkozex.github.io/categories/Algorithm/"/>
    
    
      <category term="学习笔记" scheme="http://Mkozex.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数论" scheme="http://Mkozex.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="素数" scheme="http://Mkozex.github.io/tags/%E7%B4%A0%E6%95%B0/"/>
    
      <category term="Math" scheme="http://Mkozex.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>乘法逆元</title>
    <link href="http://Mkozex.github.io/2019/04/20/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"/>
    <id>http://Mkozex.github.io/2019/04/20/乘法逆元/</id>
    <published>2019-04-20T12:35:01.000Z</published>
    <updated>2019-10-10T14:04:45.873Z</updated>
    
    <content type="html"><![CDATA[<p>乘法逆元是OI中一个很重要的数论算法，那么，该如何高效的求出乘法逆元呢？<br>$P.S.$这里我们只讨论当模数为素数的情况，因为如果模数不为素数，则不一定每个数都有逆元。</p><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>我们将$\ x\ $在$\ \mathrm{mod}\ p\ $意义下的乘法逆元称为$\ x^{-1}\ $。其有如下性质：<br>$$x\times x^{-1} \equiv1 \pmod p$$</p><h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>$$a^{p-1}\equiv 1 \pmod p$$<br>这个式子可以变形为<br>$$a\times a^{p-2}\equiv1 \pmod p$$<br>所以可得，其中的$\ a^{p-2}\ $即为$\ a\ $的乘法逆元。<br>而对于计算$\ a^{p-2}\ $,我们可以使用快速幂，时间复杂度为$O(\log a)$。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = (ans * a) % MOD;</span><br><span class="line">        a = (a * a) % MOD;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pow</span>(num, MOD - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展欧里里得"><a href="#扩展欧里里得" class="headerlink" title="扩展欧里里得"></a>扩展欧里里得</h3><p>扩展欧几里得算法本来就是用来求解形如<br>$$ax+by=\gcd(a,b)$$<br>的方程的一组整数解。<br>而当$\ b \ $为素数时，$\ \gcd(a,b)=1$,所以有<br>$$ax\equiv1 \pmod b$$<br>因此其中的$\ a\ $为$\ x \ $的乘法逆元。<br>时间复杂度为$O(\log a)$</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b, <span class="keyword">int</span> &amp;g, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) g = a, x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> exgcd(b, a % b, g, y, x), y -= x * (a / b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> g, x, y;</span><br><span class="line">    exgcd(num, p, g, x, y);</span><br><span class="line">    <span class="keyword">return</span> ((x % p) + p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递推法"><a href="#递推法" class="headerlink" title="递推法"></a>递推法</h3><p>如果设$\ p=m\times i + n\ $,$\ (n &lt;i,1&lt;i&lt;p)\ $则有<br>$$<br>m\times i +n \equiv 0\pmod p<br>$$<br>这时如果在两边同时乘上$\ n^{-1}+i^{-1}\ $，即可得<br>$$<br>m\times n^{-1}+i^{-1}\equiv 0 \pmod p<br>$$<br>即<br>$$<br>i^{-1}\equiv -\lfloor \frac{p}{i} \rfloor\times(p \bmod i)^{-1} \pmod p<br>$$<br>于是我们可以用此式来推，可得边界条件为$1^{-1}\equiv 1\pmod p$，于是此算法的时间复杂度为$O(n)$</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAXN; i++) </span><br><span class="line">    inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;乘法逆元是OI中一个很重要的数论算法，那么，该如何高效的求出乘法逆元呢？&lt;br&gt;$P.S.$这里我们只讨论当模数为素数的情况，因为如果模数不为素数，则不一定每个数都有逆元。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://Mkozex.github.io/categories/Algorithm/"/>
    
    
      <category term="学习笔记" scheme="http://Mkozex.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数论" scheme="http://Mkozex.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="Math" scheme="http://Mkozex.github.io/tags/Math/"/>
    
      <category term="乘法逆元" scheme="http://Mkozex.github.io/tags/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"/>
    
  </entry>
  
  <entry>
    <title>裴蜀定理与ex-gcd</title>
    <link href="http://Mkozex.github.io/2019/03/31/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86%E4%B8%8Eex-gcd/"/>
    <id>http://Mkozex.github.io/2019/03/31/裴蜀定理与ex-gcd/</id>
    <published>2019-03-31T08:30:47.000Z</published>
    <updated>2019-10-10T14:04:57.066Z</updated>
    
    <content type="html"><![CDATA[<p>$\ \mathrm{ex-gcd}\ $可以求解形如$\ ax+by=c\ $的不定方程，而裴蜀定理则作为其的理论依据，是个十分重要的算法（废话</p><a id="more"></a><p>首先是裴蜀定理</p><h2 id="裴蜀定理的内容"><a href="#裴蜀定理的内容" class="headerlink" title="裴蜀定理的内容"></a>裴蜀定理的内容</h2><p>裴蜀定理,它指的是<br>$$\mathrm{gcd}(a,b)|d\Leftrightarrow\exists u,v\ such \ that\ ua+vb=d$$</p><h2 id="裴蜀定理的证明"><a href="#裴蜀定理的证明" class="headerlink" title="裴蜀定理的证明"></a>裴蜀定理的证明</h2><p>首先当$u=1\ ,\ v=0$时，结论成立<br>假设存在$u’\ ,\ v’$使得$\ u’b+v’(a\bmod{b})=d$<br>因为$$\mathrm{gcd}(a,b)=\mathrm{gcd}(b,a\bmod{b}))$$<br>因为$$a\bmod{b}=a-\left\lfloor \frac{a}{b}\right\rfloor b$$<br>可得$$u’b+v’(a-\left\lfloor \frac{a}{b}\right\rfloor b)=d$$<br>整理可得$$v’a+(u’-\left\lfloor \frac{a}{b}\right\rfloor v’)b=d$$<br>归纳证明该定理正确</p><h2 id="裴蜀定理的推广"><a href="#裴蜀定理的推广" class="headerlink" title="裴蜀定理的推广"></a>裴蜀定理的推广</h2><p>由此可推广至多项时的情景：方程$a_1x_1+a_2x_2+\cdots+a_ix_i=f$有解的充要条件为$\mathrm{gcd} (a_1,a_2,\cdots a_i)|f$<br>还可将其拓展为求$ax+by=c$中的最小非负的$c$，易得其解为$\mathrm{gcd}(a,b)$</p><h2 id="mathrm-ex-gcd"><a href="#mathrm-ex-gcd" class="headerlink" title="$\mathrm{ex-gcd}$"></a>$\mathrm{ex-gcd}$</h2><p>既然有了裴蜀定理，那我们就可以借此来求解满足$\ ax+by=\mathrm{gcd}(a,b)\ $的解$ \ x\ , \ y$<br>首先，因为当$b=0\ $时，有解为$\ x=1\ ,\ y=0\ $，所以就得出了递归边界<br>所以可以得出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ex_gcd</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;g, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) x = <span class="number">1</span>, y = <span class="number">0</span>,  g = a; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ex_gcd(b, a % b, g, y, x);</span><br><span class="line">        y -= a / b * x;<span class="comment">//因为递归不影响最后结果，所以在最后减去a / b * x即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一道题"><a href="#一道题" class="headerlink" title="一道题"></a>一道题</h2><p>求满足$\ Ax+By=C\ $的任意一组解</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>我们不妨先求出满足$\ Ax+By=\mathrm{gcd}(A,B)$的解，而这是上述方程的一组特解，接下来只需判断$\mathrm{gcd}(A,B)|C$即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ex_gcd</span> <span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;x = <span class="number">1</span>; y = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;ex_gcd(b, a % b, y, x); y -= a / b * x;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll a, b, c, x = <span class="number">0</span>, y = <span class="number">0</span>, gcd;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    c = -c; </span><br><span class="line">    ex_gcd(a, b, x, y);  </span><br><span class="line">    gcd = a * x + b * y;</span><br><span class="line">    <span class="keyword">if</span> (c % gcd) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;  </span><br><span class="line">    x = c / gcd * x; </span><br><span class="line">    y = c / gcd * y;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><del>扩欧真好吃</del></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$\ \mathrm{ex-gcd}\ $可以求解形如$\ ax+by=c\ $的不定方程，而裴蜀定理则作为其的理论依据，是个十分重要的算法（废话&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://Mkozex.github.io/categories/Algorithm/"/>
    
    
      <category term="学习笔记" scheme="http://Mkozex.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数论" scheme="http://Mkozex.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="Math" scheme="http://Mkozex.github.io/tags/Math/"/>
    
      <category term="欧几里得算法" scheme="http://Mkozex.github.io/tags/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
