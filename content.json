{"meta":{"title":"Mkozex","subtitle":"胡思乱想啦","description":null,"author":"Mkozex","url":"http://Mkozex.github.io","root":"/"},"pages":[{"title":"关于","date":"2018-12-12T14:14:36.000Z","updated":"2020-03-04T09:00:23.078Z","comments":false,"path":"about/index.html","permalink":"http://Mkozex.github.io/about/index.html","excerpt":"","text":"在ZJ弱校的一个菜鸡，喜欢数学和信息，也欢迎交换友链！"},{"title":"归档","date":"2019-07-12T11:44:23.000Z","updated":"2020-03-06T08:44:19.012Z","comments":false,"path":"archives/index.html","permalink":"http://Mkozex.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-07-12T11:44:08.000Z","updated":"2020-03-06T08:44:01.390Z","comments":false,"path":"categories/index.html","permalink":"http://Mkozex.github.io/categories/index.html","excerpt":"","text":""},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-10-05T11:00:57.511Z","comments":true,"path":"links/index.html","permalink":"http://Mkozex.github.io/links/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-13T03:47:38.000Z","updated":"2020-03-04T08:55:56.365Z","comments":true,"path":"friends/index.html","permalink":"http://Mkozex.github.io/friends/index.html","excerpt":"","text":"siyuan: orzsiyuan.com Menci: men.ci Kano: kanocui.top Herself32: cotoliqwq.github.io/"},{"title":"标签","date":"2019-07-12T11:43:50.000Z","updated":"2020-03-06T08:43:39.019Z","comments":false,"path":"tags/index.html","permalink":"http://Mkozex.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"DFS","slug":"DFS","date":"2020-09-12T14:21:23.000Z","updated":"2020-09-12T12:25:34.555Z","comments":true,"path":"2020/09/12/DFS/","link":"","permalink":"http://Mkozex.github.io/2020/09/12/DFS/","excerpt":"DFS 序列我们可以通过记录调用 DFS 的 时间戳 来实现一棵树/图的 DFS 序列。","text":"DFS 序列我们可以通过记录调用 DFS 的 时间戳 来实现一棵树/图的 DFS 序列。 具体的，我们只需在 PREVISIT 和 POSTVISIT 中添加如下代码： 12345678void PREVISIT(int u) &#123; pre[u] = ++tim; dfn[tim] = u;&#125;void POSTVISIT(int u) &#123; post[u] = tim;&#125; 例如下面这棵树： 我们可以容易的写出其对应的 pre 、 post 数组： $i$（结点编号） $1$ $2$ $3$ $4$ $5$ $pre[i]$ $1$ $2$ $6$ $3$ $5$ $post[i]$ $6$ $5$ $6$ $4$ $5$ 以及 dfn 数组就是 pre 所对应的映射。 我们可以通过 DFS 序发现许多性质，例如：$pre[i] - post[i]=$ 该节点的子树大小。 因此，我们可以用 DFS 序完成许多树上问题。 单点修改，子树和查询LOJ 144 可利用树状数组完成， $pre [i]$ 单点加，$pre[i]\\sim post[i]$ 区间查询。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e6 + 10;vector&lt;int&gt; G[N];ll pre[N], post[N], sz[N], t[N];int tim = 0, n, m, rt, a[N];void dfs(int u, int fa) &#123; pre[u] = ++tim; int d = G[u].size(); for (int i = 0; i &lt; d; ++i) &#123; int v = G[u][i]; if (v == fa) continue; dfs(v, u); &#125; post[u] = tim;&#125;int lowbit(int x) &#123; return x &amp; -x; &#125;void add(int x, int k) &#123; for (; x &lt;= n; x += lowbit(x)) t[x] += k;&#125;ll query(int x) &#123; ll ans = 0; for (; x; x -= lowbit(x)) ans += t[x]; return ans;&#125;int main() &#123; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;rt); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= n - 1; ++i) &#123; int u, v; scanf(\"%d %d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(rt, 0); for (int i = 1; i &lt;= n; ++i) &#123; add(pre[i], a[i]); &#125; for (int i = 1; i &lt;= m; ++i) &#123; int opt, x, y; scanf(\"%d\", &amp;opt); if (opt == 1) &#123; scanf(\"%d %d\", &amp;x, &amp;y); add(pre[x], y); &#125; else &#123; scanf(\"%d\", &amp;x); printf(\"%lld\\n\", query(post[x]) - query(pre[x] - 1)); &#125; &#125; return 0;&#125; 子树修改，子树和查询LOJ 145 用两个树状数组或者线段树（可能要卡空间）， $pre[i]\\sim post[i]$ 区间加，区间查询。 不过，这道题好像暴力也可以搞过去？ 树的重心定义对于树上的每一个点，计算其所有子树中最大的子树节点数，这个值最小的点就是这棵树的重心。 性质1.以树的重心为根时，所有子树的大小都不超过整棵树大小的一半。 2.树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。 3.把两棵树通过一条边相连得到一棵新的树，那么新的树的重心在连接原来两棵树的重心的路径上。 4.在一棵树上添加或删除一个叶子，那么它的重心最多只移动一条边的距离。 5.一棵树的重心一定在这棵树的重链上 实现在 DFS 中计算每个子树的大小，记录“向下”的子树的最大大小，利用总点数 - 当前子树（这里的子树指有根树的子树）的大小得到“向上”的子树的大小，然后就可以依据定义找到重心了。 1234567891011121314151617void Centroid(int u, int fa) &#123; siz[u] = 1; son[u] = 0; int d = G[u].size(); for (int i = 0; i &lt; d; ++i) &#123; int v = G[u][i]; if (v != fa) P&#123; Centroid(v, u); siz[u] += siz[v]; son[u] = max(son[u], n - siz[v]); &#125; &#125; son[u] = max(son[u], n - siz[u]); if (rt == 0 || son[u] &lt; son[rt]) &#123; rt = u; // rt为重心编号 &#125;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://Mkozex.github.io/categories/Algorithm/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://Mkozex.github.io/tags/图论/"},{"name":"DFS序","slug":"DFS序","permalink":"http://Mkozex.github.io/tags/DFS序/"},{"name":"DFS","slug":"DFS","permalink":"http://Mkozex.github.io/tags/DFS/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://Mkozex.github.io/tags/学习笔记/"},{"name":"LOJ","slug":"LOJ","permalink":"http://Mkozex.github.io/tags/LOJ/"}]},{"title":"「IMO2019」T1","slug":"「IMO2019」解答","date":"2020-03-22T11:44:13.000Z","updated":"2020-03-23T06:04:39.026Z","comments":true,"path":"2020/03/22/「IMO2019」解答/","link":"","permalink":"http://Mkozex.github.io/2020/03/22/「IMO2019」解答/","excerpt":"最近看了质心关于 IMO2019 的解答，但是只会第 $1$ 题，于是就想记录一下。","text":"最近看了质心关于 IMO2019 的解答，但是只会第 $1$ 题，于是就想记录一下。 题目设整数集为 $\\mathbb{Z}.$ 求所有函数 $f:\\mathbb{Z} \\to \\mathbb{Z}$ 使得对任意整数 $a,b$ 都有$$f(2a) + 2f(b) = f(f(a + b)).$$ 解答我们可以用 $a + 1$ 替换 $a$ ，用 $b - 1$ 替换 $b$ 。 于是原方程变为$$f(2a + 2) + 2f(b - 1) = f(f(a + b))$$然后与原式作差$$f(2a + 2) - f(2a) = 2(f(b) - f(b - 1))$$将 $a = 0$ 代入$$f(b) - f(b - 1) = \\frac{f(2) - f(0)}{2}$$于是可以得到该函数为线性增长的函数，因此，设 $f(0) = m$ ，可得 $f(x) = m + dx$ 。 接下来分类讨论 $\\mathbb{1.}\\ d = 0\\ ,\\ f(x) = m.$ 将 $a = b = 0$ 代入$$\\begin{align}f(0) + 2f(0) &amp;= f(f(0)) \\newline3m &amp;= m\\newline\\therefore m &amp;= 0\\end{align}$$所以 $f(x) = 0$ 。 $\\mathbb{2.}\\ d \\neq 0.$$$\\begin{align}f(0) + 2f(0) &amp;= f(f(0))\\newline3m &amp;= f(m)\\newline\\therefore dm &amp;= 2m\\end{align}$$然后再分情况考虑 $\\mathbb{2.1.}\\ m = 0\\ ,\\ f(x) = dx.$ 代入原式$$\\begin{align}2ad + 2bd &amp;= f((a + b)d) = (a + b)d^2\\newline2d(a + b) &amp;= d^2 (a + b)\\newline\\therefore d &amp;= 2\\end{align}$$所以 $f(x) = 2x$ 。 $\\mathbb{2.2.}\\ m \\neq 0\\ ,\\ d = 2.$ 此时 $f(x) = 2x + m$ 。 代入原式$$\\begin{align}4a + m + 2 (2b + m) &amp;= f(2a + 2b +m) = 2(2a + 2b + m) + m\\newline4a + 4b + 3m &amp;= 4a + 4b + 3m\\newline\\therefore m &amp;\\in \\mathbb{Z}\\end{align}$$综上所述 $f(x) = 0$ 或 $f(x) = 2x + m\\ ,\\ m \\in \\mathbb{Z}$ 。","categories":[{"name":"Mathematic","slug":"Mathematic","permalink":"http://Mkozex.github.io/categories/Mathematic/"}],"tags":[{"name":"Math","slug":"Math","permalink":"http://Mkozex.github.io/tags/Math/"},{"name":"函数","slug":"函数","permalink":"http://Mkozex.github.io/tags/函数/"}]},{"title":"FHQ-Treap","slug":"FHQ-Treap","date":"2020-03-05T08:21:23.000Z","updated":"2020-03-08T09:57:07.803Z","comments":true,"path":"2020/03/05/FHQ-Treap/","link":"","permalink":"http://Mkozex.github.io/2020/03/05/FHQ-Treap/","excerpt":"“平衡树好麻烦啊，转来转去的，好难理解啊，而且 $\\text{Treap}$ 还不能解决区间序列问题。” “有一种无旋的 $\\text{Treap}$ ，叫 $\\text{FHQ-Treap}$ ，还可以解决区间序列问题呢！”","text":"“平衡树好麻烦啊，转来转去的，好难理解啊，而且 $\\text{Treap}$ 还不能解决区间序列问题。” “有一种无旋的 $\\text{Treap}$ ，叫 $\\text{FHQ-Treap}$ ，还可以解决区间序列问题呢！” 前置芝士因为 $\\text{FHQ-Treap}$ 是基于 $\\text{Treap}$ 的所以需要先大致了解一下 $\\text{Treap}$ 的性质。 顾名思义， $\\text{Treap = Tree + Heap}$ ，因此， $\\text{Treap}$ 被称作树堆，是指一有一个随机附加域满足堆的性质的二叉搜索树，其结构相当于以随机数据插入的二叉搜索树。其基本操作的期望时间复杂度为 $O(\\log n)$ ，能基本实现随机平衡的结构。 相对于 $\\text{Treap}$ ， $\\text{FHQ-Treap}$ 的代码更为简洁，且省去了繁琐的旋转操作，降低了调试难度。 核心操作分割$\\text{FHQ-Treap}$ 的分割分为两种，一种是按照权值分割，一种是按照大小分割。（图丑不要介意qwq 按照权值分割 权值分割即是将权值按照 $val$ 分割 $\\ge\\ val$ 和 $&lt; val$ 成两部分。 例如，对于图中的树，我们假设要将其按照 $val = 75$ 分成两部分。 那么第一次分割，此时根节点为橙色结点，因为 $50&lt;75$ ，又因为平衡树的性质，所以就按照红线分成了两部分。 第二次分割，此时根节点变为了黄色结点，因为 $80 &gt; 75$ ，所以就按照蓝线又分成了两部分。 第三次分割，此时根节点变成了粉色结点，因为 $70 &lt; 75$ ，所以将这个叶结点归为 $&lt;75$ 的部分。 至此，这棵树就按照 $val = 75$ 分成了两部分。 12345678910111213void split_val(int p, int val, int &amp;x, int &amp;y) &#123; if (!p) &#123; x = y = 0; return ; &#125; else if (t[p].val &lt;= val) &#123; x = p; split_val(rs(p), val, rs(p), y); &#125; else &#123; y = p; split_val(ls(p), val, x, ls(p)); &#125; up(p);&#125; 按照大小分割大小分割即是将前 $k$ 个结点 例如，对于图中的树，我们假设要将其前 $4$ 个结点分割出来。 那么第一次分割，此时根节点为橙色结点，因为左子树的大小 $+1&lt;4$ ，所以就按照红线分成了两部分。 第二次分割，此时根节点变为了黄色结点，因为左子树的大小 $+1=4$ ，所以就按照蓝线又分成了两部分，并且将剩下的粉色结点归为另一部分中。 12345678910111213void split_sz(int p, int k, int &amp;x, int &amp;y) &#123; if (!p) &#123; x = y = 0; return ; &#125; else if (t[ls(p)].sz + 1 &lt;= k) &#123; x = p; split_sz(rs(p), k - t[ls(p)].sz - 1, rs(p), y); &#125; else &#123; y = p; split_sz(ls(p), k, x, ls(p)); &#125; up(p);&#125; 合并 （画图好难）假设现在我们要合并 $x$ 和 $y$ ，那么此时我们可以通过比较随机附加域的大小来合并。 注：图中的红色结点为当前根节点。 图 $1$ ，因为 $rd_x &lt; rd_y$ ，于是我们固定 $x$ 以及它的左子树，让它的右子树继续和 $y$ 合并。 接下来图 $2$ ，因为此时 $rd_x &gt; rd_y$ ，于是我们固定 $y$ 以及它的右子树（也就是让 $y$ 与根节点合并），让它的左子树继续和 $x$ 合并。 同理，可依次得到图 $3,\\ 4,\\ 5 $ ，最后返回最后合并的结点。 123456789101112int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (t[x].rd &lt; t[y].rd) &#123; rs(x) = merge(rs(x), y); up(x); return x; &#125; else &#123; ls(y) = merge(x, ls(y)); up(y); return y; &#125;&#125; 其他操作因为 $\\text{FHQ-Treap}$ 运用了函数式变成的方法，因此，其他操作都是通过 $\\text{split}$ 和 $\\text{merge}$ 实现的。 插入插入可以直接按照新的结点的权值分割，然后将结点放到第一棵树的后面，然后依次合并。 12345void insert(int val) &#123; int x, y; split_val(rt, val, x, y); rt = merge(merge(x, newnode(val)), y);&#125; 其中的 noewnode 就是新建一个结点。 12345int newnode(int val) &#123; t[++tot].sz = 1; t[tot].val = val, t[tot].rd = rand(); return tot;&#125; 删除因为权值为 $val$ 的结点可能有多个，所以我们可以先按照 $val$ 进行权值分割，用 $x$ 记录这个根，再在 $x$ 树中按照 $val - 1$ 再次进行权值分割，并且用 $y$ 记录这个根。 那么此时 $val$ 这个权值已经被分离到了以 $y$ 为根的树中，即可直接将这个结点的位置用它的左儿子和右儿子合并后的根代替。最后将分割出来的树依次合并就可以了。 1234567void remove(int val) &#123; int x, y, z split_val(rt, val, x, z); split_val(x, val - 1, x, y); y = merge(ls(y), rs(y)); rt = merge(x, merge(y, z));&#125; 查询排名我们可以直接将所有比要查询的数小的权值分割到一棵树中，那么这个数的排名就是分割出的这棵树 $+1$ 了。 1234567int rank(int val) &#123; int x, y; split_val(rt, val - 1, x, y); int ans = t[x].sz + 1; rt = merge(x, y); return ans;&#125; 第k大数我们可以把前 $k - 1$ 个数拿出来，再从剩下的树中找第 $1$ 个元素就是答案了。用 split_sz 就可以实现啦。 12345678int kth(int rt, int p)&#123; int x, y, z; split_sz(rt, p - 1, x, y); split_sz(y, 1, y, z); int ans = y; rt = merge(merge(x, y), z); return ans;//返回第k大数的序号&#125; 查询前驱先得到 $1$ 到 $val - 1$ 构成的树，然后用 kth 函数即可求出最大的元素， 即是前驱。 1234567int pre(int val) &#123; int x, y; split_val(rt, val - 1, x, y); int ans = kth(x, t[x].sz); rt = merge(x, y); return ans;&#125; 查询后继同查询前驱一样，我们可以先得到 $1 - v$ 构成的树，再用 kth 求出剩下树中最小的与元素，即是后继。 1234567int suc(int val) &#123; int x, y; split_val(rt, val, x, y); int ans = kth(y, 1); rt = merge(x, y); return ans;&#125; 代码LOJ 104普通平衡树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;#define ls(x) t[x].ch[0]#define rs(x) t[x].ch[1]using namespace std;const int N = 1e5 + 10;int tot = 0, rt = 0;int q;struct node &#123; int ch[2], val, sz, rd;&#125; t[N];void up(int x) &#123; t[x].sz = t[ls(x)].sz + t[rs(x)].sz + 1;&#125;void split_val(int p, int val, int &amp;x, int &amp;y) &#123; if (!p) &#123; x = y = 0; return ; &#125; else if (t[p].val &lt;= val) &#123; x = p; split_val(rs(p), val, rs(p), y); &#125; else &#123; y = p; split_val(ls(p), val, x, ls(p)); &#125; up(p);&#125; void split_sz(int p, int k, int &amp;x, int &amp;y) &#123; if (!p) &#123; x = y = 0; return ; &#125; else if (t[ls(p)].sz + 1 &lt;= k) &#123; x = p; split_sz(rs(p), k - t[ls(p)].sz - 1, rs(p), y); &#125; else &#123; y = p; split_sz(ls(p), k, x, ls(p)); &#125; up(p);&#125; int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (t[x].rd &lt; t[y].rd) &#123; rs(x) = merge(rs(x), y); up(x); return x; &#125; else &#123; ls(y) = merge(x, ls(y)); up(y); return y; &#125;&#125;int newnode(int val) &#123; t[++tot].sz = 1; t[tot].val = val, t[tot].rd = rand(); return tot;&#125;void insert(int val) &#123; int x, y; split_val(rt, val, x, y); rt = merge(merge(x, newnode(val)), y);&#125;void remove(int val) &#123; int x, y, z; split_val(rt, val, x, z); split_val(x, val - 1, x, y); y = merge(ls(y), rs(y)); rt = merge(merge(x, y), z);&#125;int rank(int val) &#123; int x, y; split_val(rt, val - 1, x, y); int ans = t[x].sz + 1; rt = merge(x, y); return ans;&#125;int kth(int rt, int p)&#123; int x, y, z; split_sz(rt, p - 1, x, y); split_sz(y, 1, y, z); int ans = y; rt = merge(merge(x, y), z); return ans;&#125;int pre(int val) &#123; int x, y; split_val(rt, val - 1, x, y); int ans = kth(x, t[x].sz); rt = merge(x, y); return ans;&#125;int suc(int val) &#123; int x, y; split_val(rt, val, x, y); int ans = kth(y, 1); rt = merge(x, y); return ans;&#125;int main() &#123; scanf(\"%d\", &amp;q); int opt, x; while (q--) &#123; scanf(\"%d %d\", &amp;opt, &amp;x); if (opt == 1) insert(x); if (opt == 2) remove(x); if (opt == 3) printf(\"%d\\n\", rank(x)); if (opt == 4) printf(\"%d\\n\", t[kth(rt, x)].val); if (opt == 5) printf(\"%d\\n\", t[pre(x)].val); if (opt == 6) printf(\"%d\\n\", t[suc(x)].val); &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://Mkozex.github.io/categories/Algorithm/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Mkozex.github.io/tags/学习笔记/"},{"name":"数据结构","slug":"数据结构","permalink":"http://Mkozex.github.io/tags/数据结构/"},{"name":"平衡树","slug":"平衡树","permalink":"http://Mkozex.github.io/tags/平衡树/"},{"name":"FHQ-Treap","slug":"FHQ-Treap","permalink":"http://Mkozex.github.io/tags/FHQ-Treap/"}]},{"title":"「CSMO」一道有趣的集合问题","slug":"「CSMO」一道有趣的集合问题","date":"2020-02-27T01:57:30.000Z","updated":"2020-02-27T05:14:28.919Z","comments":true,"path":"2020/02/27/「CSMO」一道有趣的集合问题/","link":"","permalink":"http://Mkozex.github.io/2020/02/27/「CSMO」一道有趣的集合问题/","excerpt":"设 $x, y, z, u\\in \\mathbb{Z}\\ , 1\\le x, y, z, u\\le 10$ ，求试下列不等式成立的有序四元数组 $(x, y, z, y)$ 的个数：$$\\frac{x-y}{x+y}+\\frac{y-z}{y + z}+\\frac{z-u}{z+u}+\\frac{u-x}{u+x} &gt; 0$$","text":"设 $x, y, z, u\\in \\mathbb{Z}\\ , 1\\le x, y, z, u\\le 10$ ，求试下列不等式成立的有序四元数组 $(x, y, z, y)$ 的个数：$$\\frac{x-y}{x+y}+\\frac{y-z}{y + z}+\\frac{z-u}{z+u}+\\frac{u-x}{u+x} &gt; 0$$ 看到的一道题，看上去十分的不可做，看了一下提示，终于弄出来了。 解答令$$\\begin{align}&amp;f(a, b, c,d) = \\frac{a-b}{a+b}+\\frac{b-c}{b + c}+\\frac{c-d}{c+d}+\\frac{d-a}{d+a}\\newlineA &amp;= {(x,y,z,u)\\ |\\ 1\\le x,y,z,u \\le 10,\\ f(x,y,z,u) &gt; 0 }\\newlineB &amp;= {(x,y,z,u)\\ |\\ 1\\le x,y,z,u \\le 10,\\ f(x,y,z,u) &lt; 0 }\\newlineC &amp;= {(x,y,z,u)\\ |\\ 1\\le x,y,z,u \\le 10,\\ f(x,y,z,u) = 0 }\\end{align}$$题目要求的即是 $|A|$ 。 因为 $x,y,z,y$ 均有 $10$ 种情况，于是有$$|A|+|B|+|C| = 10^4$$由$$\\begin{align}f(x,y,z,u) &gt; 0&amp;\\iff \\frac{y-x}{x+y}+\\frac{z-y}{y + z}+\\frac{u-z}{z+u}+\\frac{x-u}{u+x} &lt; 0\\newline&amp;\\iff \\frac{x-u}{x+u}+\\frac{u-z}{u + z}+\\frac{z-y}{z+y}+\\frac{y-x}{y+x} &gt; 0\\newline&amp;\\iff f(x,u,z,y) &lt; 0\\end{align}$$得 $|A| = |B|$ 。 下面计算 $|C|$$$\\begin{align}&amp;\\frac{x-y}{x+y}+\\frac{y-z}{y + z}+\\frac{z-u}{z+u}+\\frac{u-x}{u+x} = 0\\newline\\iff &amp;\\frac{xz-yu}{(x+y)(z+u)} = \\frac{xz-yu}{(y+z)(x+u)}\\newline\\iff &amp;(xz-yu)(xy+zu-yu-xu) = 0\\newline\\iff &amp;(xz-yu)(z-x)(u-y) = 0\\end{align}$$令$$\\begin{align}C_1 &amp;= { (x, y, z, u)\\ |\\ x = z }\\newlineC_1 &amp;= { (x, y, z, u)\\ |\\ x \\neq z,\\ y = u }\\newlineC_1 &amp;= { (x, y, z, u)\\ |\\ x =\\neq z,\\ y \\ne u ,\\ xz = yu}\\end{align}$$$\\Rightarrow |C_1| = 10^3,\\ |C_2| = 900$ 。 下面求 $|C_3|$ ， 有 $3$ 种情况： $\\mathbf{1.}\\ x \\neq z, x = y, z = u \\Rightarrow 90$ 种 $\\mathbf{2.}\\ x \\neq z, x = u, y = z \\Rightarrow 90$ 种 $\\mathbf{3.}\\ xz \\neq yu$ ， 且 $x,y,z,u$ 互不相等 枚举得到有$$\\begin{align}&amp;(1,6,2,3)&amp; &amp;(1,8,2,4)&amp; &amp;(1,10,2,5)\\newline&amp;(2,6,3,4)&amp; &amp;(2,9,3,6)&amp; &amp;(3,8,4,6)\\newline&amp;(3,10,5,6)&amp; &amp;(4,10,5,8)&amp; &amp;(2,10,4,5)\\end{align}$$又因为四元数组有序，所以每组有 $2\\times 4 = 8$ 种排列，因此有 $8 \\times 9 = 72$ 种。 所以可以得到 $|C| = |C_1|+|C_2|+|C_3|=2152$ 。 因此题目所求 $= |A| = \\frac{10^4 - |C|}{2} = 3924$ 。","categories":[{"name":"Mathematic","slug":"Mathematic","permalink":"http://Mkozex.github.io/categories/Mathematic/"}],"tags":[{"name":"Math","slug":"Math","permalink":"http://Mkozex.github.io/tags/Math/"},{"name":"集合","slug":"集合","permalink":"http://Mkozex.github.io/tags/集合/"}]},{"title":"「NOI2001」食物链-种类并查集","slug":"「NOI2001」食物链-种类并查集","date":"2020-02-25T09:40:39.000Z","updated":"2020-02-27T06:30:57.283Z","comments":true,"path":"2020/02/25/「NOI2001」食物链-种类并查集/","link":"","permalink":"http://Mkozex.github.io/2020/02/25/「NOI2001」食物链-种类并查集/","excerpt":"动物王国中有三类动物 ${A,\\ B,\\ C}$，这三类动物的食物链构成了有趣的环形。${A}$ 吃 ${B}$ ， ${B}$ 吃 ${C}$ ， ${C}$ 吃 ${A}$ 。现有 $N$ 个动物，以 $1-N$ 编号。每个动物都是 ${A,\\ B,\\ C} $ 中的一种，但是我们并不知道它到底是哪一种。 有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述： 第一种说法是“ ${1\\ X\\ Y}$ ”，表示 ${X}$ 和 ${Y}$ 是同类。 第二种说法是“ ${2\\ X\\ Y}$ ”，表示 ${X}$ 吃 ${Y}$ 。 此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 当前的话与前面的某些真的话冲突，就是假话 当前的话中 ${X}$ 或 ${Y}$ 比 $N$ 大，就是假话 当前的话表示 ${X}$ 吃 ${X}$，就是假话 你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。","text":"动物王国中有三类动物 ${A,\\ B,\\ C}$，这三类动物的食物链构成了有趣的环形。${A}$ 吃 ${B}$ ， ${B}$ 吃 ${C}$ ， ${C}$ 吃 ${A}$ 。现有 $N$ 个动物，以 $1-N$ 编号。每个动物都是 ${A,\\ B,\\ C} $ 中的一种，但是我们并不知道它到底是哪一种。 有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述： 第一种说法是“ ${1\\ X\\ Y}$ ”，表示 ${X}$ 和 ${Y}$ 是同类。 第二种说法是“ ${2\\ X\\ Y}$ ”，表示 ${X}$ 吃 ${Y}$ 。 此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 当前的话与前面的某些真的话冲突，就是假话 当前的话中 ${X}$ 或 ${Y}$ 比 $N$ 大，就是假话 当前的话表示 ${X}$ 吃 ${X}$，就是假话 你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。 链接Luogu P2024 题解众所周知，普通的并查集能够维护连通性与传递性。但对于这道题目，存在生产、消费和中立的三种情况，就不能用简单的并查集维护了，于是就有了种类并查集。 对于本题，我们可以将并查集分为 $3$ 个部分，分别表示生产 $(A)$ 、消费 $(B)$ 、中立 $(C)$ 的情况。即： $1-n$ 为 $A$ 群系， $n-2n$ 为 $B$ 群系， $2n-3n$ 为 $C$ 群系。 于是，每当有一句真话时，就要对这三组元素都加以合并。 接下来就是对于假话的判断： 当一句话表示 $X$ 和 $Y$ 是同类时，只要判断它们是否有吃或被吃的关系即可。 当一句话表示 $X$ 吃 $Y$ 时，只要判断它们是否是同类或者是否有 $X$ 被 $Y$ 吃的情况即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 +10;int fa[3 * N], n, k, ans;int find(int x) &#123; if (x == fa[x]) return x; else return fa[x] = find(fa[x]);&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;k); for (int i = 1; i &lt;= 3 * n; ++i) fa[i] = i; int opt, x, y; for (int i = 1; i &lt;= k; ++i) &#123; scanf(\"%d %d %d\", &amp;opt, &amp;x, &amp;y); if (x &gt; n || y &gt; n) &#123; ans++; continue; &#125; if (opt == 1) &#123; if (find(x + n) == find(y) || find(x) == find(y + n)) ans++; else &#123; fa[find(x)] = find(y); fa[find(x + n)] = find(y + n); fa[find(x + n + n)] = find(y + n + n); &#125; &#125; else &#123; if (find(x) == find(y) || find(x) == find(y + n)) ans++; else &#123; fa[find(x + n)] = find(y); fa[find(x + n + n)] = find(y + n); fa[find(x)] = find(y + n + n); &#125; &#125; &#125; printf(\"%d\", ans); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://Mkozex.github.io/categories/Solution/"}],"tags":[{"name":"Luogu","slug":"Luogu","permalink":"http://Mkozex.github.io/tags/Luogu/"},{"name":"数据结构","slug":"数据结构","permalink":"http://Mkozex.github.io/tags/数据结构/"},{"name":"并查集","slug":"并查集","permalink":"http://Mkozex.github.io/tags/并查集/"}]},{"title":"「ZROI」徐强强-欧拉公式+平面图","slug":"「ZROJ」徐强强","date":"2020-02-24T08:15:20.000Z","updated":"2020-03-11T07:15:24.494Z","comments":true,"path":"2020/02/24/「ZROJ」徐强强/","link":"","permalink":"http://Mkozex.github.io/2020/02/24/「ZROJ」徐强强/","excerpt":"有一个无穷大的二维平面和一个点，现在有 $n\\ (n\\le 5\\times 10^6)$ 个操作其中每次操作都是将这个点往上、下、左、右四个方向移动一个单位长度。求移动的路径能将平面分成多少个联通区域。外面无限大的平面也算作一个连通区域","text":"有一个无穷大的二维平面和一个点，现在有 $n\\ (n\\le 5\\times 10^6)$ 个操作其中每次操作都是将这个点往上、下、左、右四个方向移动一个单位长度。求移动的路径能将平面分成多少个联通区域。外面无限大的平面也算作一个连通区域 题解可以运用欧拉公式 $V + E - F =2$ 。 这虽然是对于三维几何体的公式，但也可以放到二维平面中， $F$ 为联通区域个数， $E$ 为边数， $V$ 为点数。 统计时为了去重，可以开两个 $\\texttt{set}$ 分别维护点集和边集即可，复杂度 $O(n\\log n)$ 。 代码1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;const int N = 5e6 + 10;set&lt;pii&gt; S1;set&lt;pair&lt;pii, pii&gt; &gt; S2; char s[N];int main() &#123; scanf(\"%s\", s + 1); int n = strlen(s + 1); S1.insert(&#123;0, 0&#125;); for (int i = 1, x = 0, y = 0; i &lt;= n; ++i) &#123; int a = x, b = y; if (s[i] == 'L') x++; if (s[i] == 'R') x--; if (s[i] == 'U') y++; if (s[i] == 'D') y--; S1.insert(&#123;x, y&#125;); int c = x, d = y; if (a &gt; c || b &gt; d) swap(a, c), swap(b, d); S2.insert(&#123;&#123;a, b&#125;, &#123;c, d&#125;&#125;); &#125; int V = S1.size(), E = S2.size(); printf(\"%d\", E - V + 2); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://Mkozex.github.io/categories/Solution/"}],"tags":[{"name":"ZROJ","slug":"ZROJ","permalink":"http://Mkozex.github.io/tags/ZROJ/"},{"name":"平面图","slug":"平面图","permalink":"http://Mkozex.github.io/tags/平面图/"}]},{"title":"「FJOI2007」轮状病毒-找规律","slug":"「FJOI2007」轮状病毒","date":"2020-02-11T03:22:23.000Z","updated":"2020-02-25T14:43:16.666Z","comments":true,"path":"2020/02/11/「FJOI2007」轮状病毒/","link":"","permalink":"http://Mkozex.github.io/2020/02/11/「FJOI2007」轮状病毒/","excerpt":"给定 $n$ ，变成计算有多少个不同的 $n$ 轮状病毒。","text":"给定 $n$ ，变成计算有多少个不同的 $n$ 轮状病毒。 链接BZOJ 1002 题解一开始看感觉很不可做，然后就开始找规律。 我们设其为 $f_i$。 通过手玩可以发现前几项为：$$1,5,16,45,121,\\cdots$$可以发现奇数项都是平方数，偶数项都是 $5$ 乘上一个平方数，但这个好像没什么用。 后来，我又观察到了 $f_i$ 与 $f_{i - 1} \\times 3$ 很接近。通过一系列的乱搞加加减减弄出了如下式子：$$f_{i} = f_{i - 1} \\times 3 - f_{i - 2} + 2$$之后，把它扔到oeis.org上，结果$^{\\text{TM}}$还真是这玩意（找规律带师）。发现这个东西好像要用什么基尔霍夫矩阵推出来（懵）。 代码因为这个没有给模数，只能写高精了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;int n;struct Bint &#123; int s[110], len;&#125; f[110];Bint mul(Bint a, int k) &#123; for (int i = 1; i &lt;= a.len; ++i) a.s[i] *= k; for (int i = 1; i &lt;= a.len; ++i) &#123; a.s[i + 1] += a.s[i] / 10; a.s[i] %= 10; &#125; if (a.s[a.len + 1] != 0) a.len++; return a;&#125;Bint sub(Bint a, Bint b) &#123; a.s[1] += 2; int k = 1; while (a.s[k] &gt;= 10) &#123; a.s[k] %= 10; a.s[k + 1]++; k++; &#125; for (int i = 1; i &lt;= a.len; ++i) &#123; a.s[i] -= b.s[i]; if (a.s[i] &lt; 0) &#123; a.s[i] += 10; a.s[i + 1]--; &#125; &#125; while (a.s[a.len] == 0) a.len--; return a;&#125;int main() &#123; scanf(\"%d\", &amp;n); f[1].s[1] = 1, f[2].s[1] = 5; f[1].len = 1, f[2].len = 1; for (int i = 3; i &lt;= n; ++i) f[i] = sub(mul(f[i - 1], 3), f[i - 2]); for (int i = f[n].len; i &gt; 0; --i) printf(\"%d\", f[n].s[i]); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://Mkozex.github.io/categories/Algorithm/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://Mkozex.github.io/tags/BZOJ/"},{"name":"找规律","slug":"找规律","permalink":"http://Mkozex.github.io/tags/找规律/"}]},{"title":"单调栈","slug":"单调栈","date":"2020-02-03T02:11:31.000Z","updated":"2020-03-05T03:43:06.084Z","comments":true,"path":"2020/02/03/单调栈/","link":"","permalink":"http://Mkozex.github.io/2020/02/03/单调栈/","excerpt":"什么是单调栈单调栈是满足单调性的栈结构。分为单调递增栈和单调递减栈。","text":"什么是单调栈单调栈是满足单调性的栈结构。分为单调递增栈和单调递减栈。 如何使用单调栈下面以单调递增栈为例。 插入向单调栈之中插入元素时，为了维护栈的单调性，需要弹出比它小的元素。 例如，栈中自顶向下的元素为 $1, 3, 5, 7, 10, 15$ ，现在要插入元素 $8$ ,为了保证栈的单调性就需要一次弹出元素 $1,3,5,7$ ，操作后栈变为 $8, 10, 15$ 。 代码如下： 123scanf(\"%d\", &amp;x);while (!s.empty() &amp;&amp; x &gt;= s.top()) s.pop();s.push(x); 使用可从栈顶取出来一个元素，该元素满足单调性的某一端。 应用[Luogu P5788] 【模板】单调栈因为这道题要存的是元素的下标，所以我们在单调栈中存的是元素的下标。并且这道题略有卡常，于是改了一下输出。 代码如下： 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3000010;int n, a[N], f[N];stack &lt;int&gt; s;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i]); for (int i = n; i &gt;= 1; --i) &#123; while (!s.empty() &amp;&amp; a[s.top()] &lt;= a[i]) s.pop(); if (s.empty()) f[i] = 0; else f[i] = s.top(); s.push(i); &#125; for (int i = 1; i &lt;= n; ++i) printf(\"%d\", f[i]), putchar(' '); return 0;&#125; [POJ3250] Bad Hair Day这道题也是单调栈的一个简单应用，只需记录栈的大小即可。 代码如下： 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n, x;stack &lt;int&gt; s;int main() &#123; scanf(\"%d\", &amp;n); ll ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;x); while (!s.empty() &amp;&amp; x &gt;= s.top()) s.pop(); ans += s.size(); s.push(x); &#125; printf(\"%lld\", ans); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://Mkozex.github.io/categories/Algorithm/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://Mkozex.github.io/tags/数据结构/"},{"name":"单调栈","slug":"单调栈","permalink":"http://Mkozex.github.io/tags/单调栈/"}]},{"title":"「ZROJ」造数据-前缀和","slug":"「ZROJ」造数据","date":"2019-11-10T03:37:47.000Z","updated":"2020-02-11T03:19:53.730Z","comments":true,"path":"2019/11/10/「ZROJ」造数据/","link":"","permalink":"http://Mkozex.github.io/2019/11/10/「ZROJ」造数据/","excerpt":"比赛已经开始了，可是鸽王小W还没有造好数据。 他现在在赶造数据。数据是一个 $n\\times m \\ (1\\le n, m\\le 1000)$ 的矩阵 $a_{i, j}$，现在小Y对这个矩阵很感兴趣。小Y想知道，如果定义函数$$f(x_l,x_r,y_l,y_r)=\\sum_{i=x_l}^{x_r} \\sum_{j=y_l}^{y_r} a_{i,j}$$那么对于给定的 $X_l, X_r, Y_l, Y_r$ ,问$$\\sum_{1 \\le a \\le b \\le n, X_l \\le b-a+1 \\le X_r} \\ \\ \\ \\ \\ \\sum_{1 \\le c \\le d \\le m, Y_l \\le d-c+1 \\le Y_r} f(a, b, c, d)$$即询问包含行的个数在 $X_l$ 到 $X_r$ 之间，包含列的个数在 $Y_l$ 到 $Y_r$ 之间的所有子矩阵的元素和的和。 小Y一共会给出 $q$ 组询问，他想让你帮他快速回答这些询问。由于答案可能很大，小Y只要你输出答案对 $998244353$ 取模之后的结果。","text":"比赛已经开始了，可是鸽王小W还没有造好数据。 他现在在赶造数据。数据是一个 $n\\times m \\ (1\\le n, m\\le 1000)$ 的矩阵 $a_{i, j}$，现在小Y对这个矩阵很感兴趣。小Y想知道，如果定义函数$$f(x_l,x_r,y_l,y_r)=\\sum_{i=x_l}^{x_r} \\sum_{j=y_l}^{y_r} a_{i,j}$$那么对于给定的 $X_l, X_r, Y_l, Y_r$ ,问$$\\sum_{1 \\le a \\le b \\le n, X_l \\le b-a+1 \\le X_r} \\ \\ \\ \\ \\ \\sum_{1 \\le c \\le d \\le m, Y_l \\le d-c+1 \\le Y_r} f(a, b, c, d)$$即询问包含行的个数在 $X_l$ 到 $X_r$ 之间，包含列的个数在 $Y_l$ 到 $Y_r$ 之间的所有子矩阵的元素和的和。 小Y一共会给出 $q$ 组询问，他想让你帮他快速回答这些询问。由于答案可能很大，小Y只要你输出答案对 $998244353$ 取模之后的结果。 题解显然是前缀和，但如果只记一个前缀和，复杂度是 $n^4 q$，无法通过本题。 因此，我们可以考虑线预处理所有长为 $l$ ，宽为 $r$ 的答案，即求出：$$b_{l, r} = \\sum_{i = 1} ^{n - l + 1}\\sum_{j = 1} ^{m - r + 1} f(i, i + r - 1, j, j + c - 1)$$即$$\\begin{align}b_{l, r} &amp; = \\sum_{i = 1} ^{n - l + 1}\\sum_{j = 1} ^{m - l + 1} s_{i + l - 1, j + r - 1} - s_{i - 1, j + r - 1} - s_{i + l - 1, j - 1} + s_{i - 1, j - 1}\\newline&amp; = \\sum_{i = l} ^{n}\\sum_{j = r}^m s_{i, j} + \\sum_{i = l} ^{n - l + 1}\\sum_{j = r}^m s_{i, j} + \\sum_{i = l} ^{n}\\sum_{j = r}^{m - r + 1} s_{i, j} + \\sum_{i = l} ^{n - l + 1}\\sum_{j = r}^{m - r + 1} s_{i, j}\\end{align}$$记一个前缀和就可以 $O(1)$ 求出 $b_{i, j}$ 了。 于是，询问就变成了求$$\\sum_{i = X_l} ^{X_r} \\sum_{j = Y_l} ^{Y_r}b_{i, j}$$再做一遍前缀和即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for (int i = a; i &lt;= b; ++i)using namespace std;const int p = 998244353;const int N = 1010;int n, m, q;int a[N][N], s[N][N], sa[N][N], sb[N][N], sc[N][N]; int add(int a, int b) &#123; a += b; if (a &lt; p) return a; else return a - p;&#125;int sub(int a, int b) &#123; a -= b; if (a &gt;= 0) return a; else return a + p;&#125;int get(int a[][N], int xl, int xr, int yl, int yr) &#123; return add( sub( sub(a[xr][yr], a[xl - 1][yr]), a[xr][yl - 1]), a[xl - 1][yl - 1]);&#125;int main() &#123; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;q); rep(i, 1, n) &#123; rep(j, 1, m) scanf(\"%d\", &amp;a[i][j]); &#125; rep(i, 1, n) &#123; rep(j, 1, m) s[i][j] = add( sub( add(s[i - 1][j], s[i][j - 1]), s[i - 1][j - 1]), a[i][j]); &#125; rep(i, 1, n) &#123; rep(j, 1, m) sa[i][j] = add( sub( add(sa[i - 1][j], sa[i][j - 1]), sa[i - 1][j - 1]), s[i][j]); &#125; rep(i, 1, n) &#123; rep(j, 1, m) sb[i][j] = add( sub (sub (get(sa, i, n, j, m), get(sa, 0, n - i, j, m)), get(sa, i, n, 0, m - j)), get(sa, 0, n - i, 0, m - j)); &#125; rep(i, 1, n) &#123; rep(j, 1, m) sc[i][j] = add( sub( add(sc[i - 1][j], sc[i][j - 1]), sc[i - 1][j - 1]), sb[i][j]); &#125; int xl, xr, yl, yr; rep(i, 1, q) &#123; scanf(\"%d %d %d %d\", &amp;xl, &amp;xr, &amp;yl, &amp;yr); printf(\"%d\\n\", get(sc, xl, xr, yl, yr)); &#125; return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://Mkozex.github.io/categories/Solution/"}],"tags":[{"name":"前缀和","slug":"前缀和","permalink":"http://Mkozex.github.io/tags/前缀和/"},{"name":"ZROJ","slug":"ZROJ","permalink":"http://Mkozex.github.io/tags/ZROJ/"}]},{"title":"「NOIP2015」信息传递-并查集+最小环","slug":"「NOIP2015」信息传递","date":"2019-11-09T13:56:01.000Z","updated":"2020-03-07T03:31:08.878Z","comments":true,"path":"2019/11/09/「NOIP2015」信息传递/","link":"","permalink":"http://Mkozex.github.io/2019/11/09/「NOIP2015」信息传递/","excerpt":"有 $n$ 个同学（编号为 $1$ 到 $n$ ）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为 $i$ 的同学的信息传递对象是编号为 $T_i$ 的同学。 游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息， 但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自 己的生日时，游戏结束。请问该游戏一共可以进行几轮？","text":"有 $n$ 个同学（编号为 $1$ 到 $n$ ）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为 $i$ 的同学的信息传递对象是编号为 $T_i$ 的同学。 游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息， 但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自 己的生日时，游戏结束。请问该游戏一共可以进行几轮？ 链接LOJ 2421 题解一句话题解就是并查集求最小环。 如果 $A$ 将信息传递给 $B$，那么就将 $A$ 与 $B$ 连起来，同时进行更新： $d_A = d_B + 1$ 。 建好图之后可以发现，游戏结束的轮数等于图中最小环的长度。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 10;const int Minx = 0x7777777;int fa[N], d[N], n, minn = Minx;int find(int x) &#123; if (fa[x] != x) &#123; int l = fa[x]; fa[x] = find(fa[x]); d[x] += d[l]; &#125; return fa[x];&#125;void search(int a, int b) &#123; int x = find(a), y = find(b); if (x != y) fa[x] = y, d[a] = d[b] + 1; else minn = min(minn, d[a] + d[b] + 1); return;&#125;int main() &#123; scanf(\"%d\", &amp;n); int t; for (int i = 1; i &lt;= n; ++i) fa[i] = i; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;t), search(i, t); printf(\"%d\", minn); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://Mkozex.github.io/categories/Solution/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://Mkozex.github.io/tags/图论/"},{"name":"LOJ","slug":"LOJ","permalink":"http://Mkozex.github.io/tags/LOJ/"},{"name":"NOIP","slug":"NOIP","permalink":"http://Mkozex.github.io/tags/NOIP/"},{"name":"并查集","slug":"并查集","permalink":"http://Mkozex.github.io/tags/并查集/"}]},{"title":"简单DP做题记录","slug":"DP做题记录","date":"2019-11-06T12:35:01.000Z","updated":"2020-03-07T03:34:57.523Z","comments":true,"path":"2019/11/06/DP做题记录/","link":"","permalink":"http://Mkozex.github.io/2019/11/06/DP做题记录/","excerpt":"因为自己的dp太弱，于是有了这篇文章 $\\mathcal{Q\\omega Q}$ 。都是一些很sb的题目。","text":"因为自己的dp太弱，于是有了这篇文章 $\\mathcal{Q\\omega Q}$ 。都是一些很sb的题目。 开心的金明 [Luogu P1060] 将价格看成体积，价格与重要度相乘的值看成物品的价值，然后就是01背包了。 1234567891011121314151617#include &lt;bits/stdc++.h&gt;#define N 30010using namespace std;int n, m, v[N], w[N], f[N];int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d %d\", &amp;v[i], &amp;w[i]), w[i] *= v[i]; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = n; j &gt;= v[i]; --j) f[j] = max(f[j], f[j - v[i]] + w[i]); &#125; printf(\"%d\", f[n]); return 0;&#125; 货币系统[Luogu P5020] 对于一种货币系统，例如 $(4, [3, 19, 10, 6])$ ，我们发现 $19 = 10 + 3 + 3 + 3\\ ,\\ 6 = 3 + 3$，于是这个货币系统与 $(2, [3, 10])$ 对应。因此我们发现，当系统中有一种货币可以表示为另外几种货币的和时，那这种货币就没什么用了。于是就是一个像背包的东西。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;#define N 150000using namespace std;int T, n, a[N], f[N];int main() &#123; scanf(\"%d\", &amp;T); while (T--) &#123; memset(a, 0,sizeof(a)); memset(f, 0,sizeof(f)); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i]), f[a[i]] = 2; sort(a + 1, a + n + 1); for (int i = 1; i &lt;= a[n]; ++i) &#123; if (f[i] &gt; 0) &#123; for (int j = 1; j &lt;= n; ++j) if (i + a[j] &lt;= a[n]) f[i + a[j]] = 1; else break; &#125; &#125; int ans = 0; for (int i = 1; i &lt;= a[n]; ++i) if (f[i] == 2) ans++; printf(\"%d\\n\", ans); &#125; return 0;&#125; 传纸条[Luogu P1006] 根据题意，我们可以很容易的写出其四维的转移方程：$$f_{i, j, k, l} = \\max ( f_{i, j-1, k-1, l},f_{i, j-1, k, l-1},f_{i-1, j, k-1, l},f_{i-1, j, k, l-1} ) + a_{i, j} + a_{k, l}$$（其中 $f_{i, j, k, l}$ 表示的是从 $(i, j)$ 到 $(k, l)$的最大好感度。） 这样就可以AC了 考虑如何化简，可以发现对于 $i, j, k, l$ 始终有 $i + j = k + l$ ，于是可将方程减少一维。 貌似可以再优化到二维， $\\mathcal{Q\\omega Q}$ 不会。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;#define N 110using namespace std;int m, n, a[N][N], f[N][N][N];int main() &#123; scanf(\"%d %d\", &amp;m, &amp;n); for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) scanf(\"%d\", &amp;a[i][j]); for (int i = 1; i &lt;= n + m - 1; ++i) for (int j = 1; j &lt;= m; ++j) for (int k = 1; k &lt;= m; ++k) &#123; if (i - k &lt; 0 || i - j &lt; 0) continue; f[i][j][k] = max(max(f[i - 1][j][k], f[i - 1][j - 1][k]), max(f[i - 1][j][k - 1], f[i - 1][j - 1][k - 1])) + a[k][i - k + 1] + a[j][i - j + 1]; if (j == k) f[i][j][k] -= a[j][i - j + 1]; &#125; printf(\"%d\", f[n + m - 1][m][m]); return 0;&#125; 守望者的逃离[Luogu P1095] 这道题就是能用闪烁时立刻用，如果在某一时刻走路比只闪烁更优，那就选用走路。 （其实这道题连数组都不用，但为了让它看起来像个dp，我就用了） 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define N 300010using namespace std;int m, s, t, f[N];int main() &#123; scanf(\"%d %d %d\", &amp;m, &amp;s, &amp;t); for (int i = 1; i &lt;= t; ++i) if (m &gt;= 10) f[i] = f[i - 1] + 60, m -= 10; else f[i] = f[i - 1], m += 4; for (int i = 1; i &lt;= t; ++i) &#123; f[i] = max(f[i], f[i - 1] + 17); if (f[i] &gt;= s) &#123; printf(\"Yes\\n%d\", i); return 0; &#125; &#125; printf(\"No\\n%d\", f[t]); return 0;&#125; 摆花[Luogu P1077] 由题意可以看出这是个很显然的dp，我们可以设 $f_{i, j}$ 为用了 $i$ 种花摆了 $j$ 盆时的方案数。那么可以由题意得知动态转移方程为：$$f_{i, j} = \\sum_{k = 0} ^{a_i} f_{i - 1, j - k}$$ 123456789101112131415161718#include &lt;bits/stdc++.h&gt;#define N 110#define mod 1000007using namespace std;int n, m, a[N], f[N][N];int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i]); f[0][0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt;= m; ++j) for (int k = 0; k &lt;= min(j, a[i]); ++k) f[i][j] = (f[i][j] + f[i - 1][j - k]) % mod; printf(\"%d\", f[n][m]); return 0;&#125; Crested Ibis vs MonsterABC153 E 经典的01背包问题，可以选择开大空间一次解决怪兽血量低于 $0$ 的问题，也可以枚举最后一击以及怪兽血量并取最小值（我用的是这种）。 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4 + 10;const int INF = 0x3f3f3f3f;int h, n, a[N], b[N], dp[N];int main() &#123; scanf(\"%d %d\", &amp;h, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d %d\", &amp;a[i], &amp;b[i]); for (int i = 1; i &lt;= h; ++i) dp[i] = INF; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = a[i]; j &lt;= h; ++j) dp[j] = min(dp[j], dp[j - a[i]] + b[i]); &#125; int ans = INF; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = h; j &gt;= max(0, h - a[i]); --j) &#123; ans = min(ans, dp[j] + b[i]); &#125; &#125; printf(\"%d\", ans); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://Mkozex.github.io/categories/Solution/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://Mkozex.github.io/tags/DP/"},{"name":"NOIP","slug":"NOIP","permalink":"http://Mkozex.github.io/tags/NOIP/"},{"name":"Atcoder","slug":"Atcoder","permalink":"http://Mkozex.github.io/tags/Atcoder/"},{"name":"Luogu","slug":"Luogu","permalink":"http://Mkozex.github.io/tags/Luogu/"}]},{"title":"生成函数(1)-基本法则及运算","slug":"生成函数（1）-基本法则及运算","date":"2019-10-12T14:21:57.000Z","updated":"2020-03-22T11:42:02.869Z","comments":true,"path":"2019/10/12/生成函数（1）-基本法则及运算/","link":"","permalink":"http://Mkozex.github.io/2019/10/12/生成函数（1）-基本法则及运算/","excerpt":"下面的一些文章会逐步介绍生成函数（边学边写）。","text":"下面的一些文章会逐步介绍生成函数（边学边写）。 定义以及记号对于一个无限序列$\\ \\left \\langle a_0, a_1, a_2,\\cdots \\right \\rangle\\ $，我们可以很方便地将其表示成一个辅助变量$\\ z\\ $的幂级数。$$G(z) = g_0 + g_1z + g_2z^2 + \\cdots = \\sum_{k\\ge 0} g_k z^k \\tag{1}$$那么我们将$\\ G(z)\\ $称为该序列的生成函数。$\\ G(z)\\ $中$\\ z^n\\ $的系数$\\ g_n\\ $常记为$\\ [z^n]G(z)\\ $。 我们可以将$\\ (1.1)\\ $中的$\\ n\\ $拓展成整数使得运算更加方便。我们可以直接令$\\ g_{-1} = g_{-2} = \\cdots = 0 \\ $来做到这一点。 当我们处理生成函数时，会出现两种“封闭形式”。对$\\ G(z)\\ $，我们可能会有一个用$\\ z\\ $表示的封闭形式；对$\\ \\left \\langle g_n \\right \\rangle\\ $，我们可能会有一个用$\\ n\\ $表示的封闭形式（或称通项公式）。上下文会指明是哪一种。 并且，在本篇以及其他几篇中，我们不对收敛性展开任何讨论。因为我们可以严格地证明生成函数所做的每一个运算都能作为形式幂级数上的运算，这种运算时合法的，甚至是在技术不收敛时也是如此。 运算法则在下面的文章中，除非有其他的规定，我们都假设$\\ F(z)\\ $和$\\ G(z)\\ $是数列$\\ \\left \\langle f_n \\right \\rangle\\ $和$\\ \\left \\langle g_n \\right \\rangle\\ $的生成函数，并且对于任何的$\\ n &lt; 0\\ $，$\\ f_n = g_n = 0\\ $。 相加$$\\begin{align}\\alpha F(z) + \\beta G(z) &amp;= \\alpha \\sum_{n}f_n z^n + \\beta \\sum_{n} g_n z^n\\newline&amp;= \\sum_{n} (\\alpha f_n + \\beta g_n)z^n \\tag{2}\\end{align}$$ 平移 左移： $$z^m G(z) = \\sum_{n} g_n z^{n + m} = \\sum_{n}g_{n - m} z^n\\ , \\ m\\in \\mathbb{N}^* \\tag{3}$$ 右移：$$\\frac{G(z) - g_0 - g _ 1z - \\cdots - g_{m - 1} z ^ {m - 1}}{z^m} = \\sum_{n \\ge m} g_n z^{n - m} = \\sum_{n \\ge 0} g_{n - m} z ^ n \\tag{4}$$ 注意：此时$\\ g_{-1} \\sim g_{-m} \\ne 0\\ $，因此我们不能将最后那个和式扩大到对所有$ \\ n\\ $求和。 改换变量$$G(cz) = \\sum_{n} g_n (cz)^n = \\sum_{n}g_n c^nz^n \\tag{5}$$ 微分$$G’(z) = g_1 + 2g_2z + 3g_3z^2 + \\cdots =\\sum_{n} (n + 1) g_{n + 1}z^n \\tag{6}$$ 或者将其向右移一位：$$zG’(z) = \\sum_{n} ng_n z_n \\tag{7}$$ 积分$$\\int_{0} ^{z} G(t)\\mathrm{d}t = g_0 z + \\frac{1}{2}g_1z^2 + \\frac{1}{3}g_2 ^3 + \\cdots = \\sum_{n \\ge 1} \\frac{1}{n}g_{n - 1} z^n \\tag{8}$$ 相乘$$\\begin{align}F(z)G(z) &amp;= (f_0 + f_1z + f_2z^2 + \\cdots) (g_0 + g_1z + g_2z^2 + \\cdots)\\newline&amp;= f_0g_0 + (f_0g_1 + f_1g_0)z + (f_0g_2 + f_1g_1 + f_2g_0)z^2 + \\cdots\\newline&amp;= \\sum_{n}(\\sum_{k}f_kg_{n - k})z^n \\tag{9}\\end{align}$$ 这里$\\ z^n\\ $的系数$\\ \\sum_{k}f_kg_{n - k}\\ $也是后面会说到的卷积，我们会对这个东西展开较为深入的研究。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://Mkozex.github.io/categories/Algorithm/"}],"tags":[{"name":"Math","slug":"Math","permalink":"http://Mkozex.github.io/tags/Math/"},{"name":"生成函数","slug":"生成函数","permalink":"http://Mkozex.github.io/tags/生成函数/"}]},{"title":"「BZOJ1257」余数之和-数论分块","slug":"「BZOJ1257」余数之和","date":"2019-08-09T11:21:57.000Z","updated":"2020-02-25T14:44:06.456Z","comments":true,"path":"2019/08/09/「BZOJ1257」余数之和/","link":"","permalink":"http://Mkozex.github.io/2019/08/09/「BZOJ1257」余数之和/","excerpt":"给定$\\ n, k\\ $，计算$\\ \\sum_{i = 1} ^{n}k \\bmod i\\ $。","text":"给定$\\ n, k\\ $，计算$\\ \\sum_{i = 1} ^{n}k \\bmod i\\ $。 链接BZOJ 1257 题解由于$$k \\bmod i = k - i \\left\\lfloor\\frac{k}{i}\\right\\rfloor$$于是可以可以将原题的式子修改成$$\\sum_{i = 1}^{n} {k - i \\left\\lfloor\\frac{k}{i}\\right\\rfloor}\\\\Rightarrow n k - \\sum_{i = 1}^{n} {i \\left\\lfloor\\frac{k}{i}\\right\\rfloor}\\$$于是就可以很容易的看出是很显然的数论分块，$\\ i\\ $是递增的，而$\\ k/i\\ $在一段范围内是不会变化的，那么就是一个等差数列啦。因此，每次求出这一段范围，然后计算等差数列即可。 代码1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;long long n, k;int main() &#123; scanf(\"%lld%lld\", &amp;n, &amp;k); long long ans = n * k; for (int i = 1, j = 0; i &lt;= n; i = j + 1) &#123; if (k / i) j = min(n, k / (k / i)); else j = n; ans -= (k / i) * (j - i + 1) * (i + j) / 2; &#125; printf(\"%lld\", ans); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://Mkozex.github.io/categories/Solution/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://Mkozex.github.io/tags/数论/"},{"name":"Math","slug":"Math","permalink":"http://Mkozex.github.io/tags/Math/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://Mkozex.github.io/tags/BZOJ/"},{"name":"数论分块","slug":"数论分块","permalink":"http://Mkozex.github.io/tags/数论分块/"}]},{"title":"树状数组","slug":"树状数组","date":"2019-07-24T13:53:31.000Z","updated":"2020-03-05T03:54:22.893Z","comments":true,"path":"2019/07/24/树状数组/","link":"","permalink":"http://Mkozex.github.io/2019/07/24/树状数组/","excerpt":"最近，学习了树状数组这种十分常用的数据结构，真是有趣呢。 树状数组可以在常数很小的 $O(n\\log n)$ 复杂度内实现单点加法以及区间求和（区间加也行？）。","text":"最近，学习了树状数组这种十分常用的数据结构，真是有趣呢。 树状数组可以在常数很小的 $O(n\\log n)$ 复杂度内实现单点加法以及区间求和（区间加也行？）。 原理为了了解树状数组的工作原理，可以看下面这一张图 （第一行为数组 $a$ ）。 我们不妨设那些参差不齐的方块为数组$ \\ t \\ $，并且设那些从中，我们可以看出： $t[2]$ 掌控着$a[1],a[2]$； $t[4]$ 掌控着$a[1],a[2], a[3], a[4]$； $t[6]$ 掌控着$a[5],a[6]$； $t[8]$ 掌控着$a[1-8]$。 所以如果我们要计算区间和，就可以不用一个一个去加，可以利用这幅图所表示的倍增的思来进行复杂度的优化。 入门操作既然有了原理，那么就是该如何操作的问题了，但怎么知道$\\ t_i\\ $管理了$\\ a \\ $的个数呢？ 于是，我们就引入了函数lowbit(x)： 1234int lowbit(int x) &#123; //记录一共掌控了几个a return x &amp; -x;&#125; 这里的x &amp; -x是利用了计算机内部的编码特性，即补码。因此，我们可以通过lowbit(x)计算出$\\ t\\ $掌控的个数。 单点修改既然有了lowbit(x)函数，那么单点修改就很轻松了： 123void updata(int x, int k) &#123; for (; x &lt;= n; x += lowbit(x)) t[x] += k;&#125; 于是基于差分的思想，我们可以得出区间修改的代码： 1234void updata1(int l, int r, int k) &#123; updata(l, k); updata(r + 1, -k);&#125; 查询因为树状数组的性质，我们每次查询时不用单个的枚举，只需每次从需要查询的x中减去lowbit(x)即可 12345int query(int x) &#123; int ans = 0; for (; x; x -= lowbit(x)) ans += t[x]; return ans;&#125; 于是同样的，基于差分的思想，我们可以得出区间查询的代码。 123int query1(int l, int r) &#123; return query(r) - query(l - 1);&#125; 入门后的操作区间加区间求和我们当然可以用接下来的线段树，但因为现在讲的是树状数组，所以就用树状数组来解决吧，既然用一个不行，那就用两个！ 首先，因为区间和可以用两个前缀和得到，所以我们不妨对$\\ a\\ $的一个前缀$\\ r\\ $求和，即$\\sum_{i=1}^ra_i$进行考虑，不妨设$\\ a\\ $的差分数组为$\\ b\\ $ 进行推导$$\\sum_{i=1}^ra_i$$ $$=\\sum_{i=1}^r\\sum_{j=1}^ib_i$$ $$=\\sum_{i=1}^{r}b_i\\times(r-i+1)$$ $$=\\sum_{i=1}^rb_i\\times(r+1)-\\sum_{i=1}^rb_i\\times i$$ 于是，我们只需用两个树状数组分别维护$\\ \\sum b_i\\ $和$ \\ \\sum i \\times b_i\\ $即可。 代码在这呢： 12345678910111213141516171819202122232425int t1[maxn], t2[maxn], n;int lowbit(int x) &#123; return x &amp; -x;&#125;void updata(int x, int k) &#123; int h = k * x; for (; x &lt;= n; x +=lowbit(x)) t1[x] += k, t2[x] += h;&#125;int query(int *a, int x) &#123; int ans = 0; for (; x; x -= lowbit(x)) ans += t[x]; return ans;&#125;void updata1(int l, int r, int k) &#123; updata(l, k), updata(r + 1, -v)&#125;long long query1(int l, int r) &#123; return (r + 1ll) * (query(t1, r) - query(t1, l - 1)) - (query(t2, r) - query(t2, l - 1));&#125; 其他另外，树状数组还有其他一些神奇的小trick，然鹅我不会","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://Mkozex.github.io/categories/Algorithm/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Mkozex.github.io/tags/学习笔记/"},{"name":"数据结构","slug":"数据结构","permalink":"http://Mkozex.github.io/tags/数据结构/"},{"name":"树状数组","slug":"树状数组","permalink":"http://Mkozex.github.io/tags/树状数组/"}]},{"title":"「BZOJ3884」上帝与集合的正确用法-扩展欧拉定理","slug":"「BZOJ3884」上帝与集合的正确用法","date":"2019-07-20T10:20:47.000Z","updated":"2019-10-10T14:03:34.257Z","comments":true,"path":"2019/07/20/「BZOJ3884」上帝与集合的正确用法/","link":"","permalink":"http://Mkozex.github.io/2019/07/20/「BZOJ3884」上帝与集合的正确用法/","excerpt":"这道题要求的是$\\ 2^{2^{2^{\\cdots}}}\\bmod p$。","text":"这道题要求的是$\\ 2^{2^{2^{\\cdots}}}\\bmod p$。 链接BZOJ 3884 Luogu P4139 题解可以进行如下推导$$f(p)=2^{2^{2^{\\cdots}}\\bmod \\varphi(p)+ \\varphi(p)}\\pmod p$$$$=2^{f(\\varphi(p))+ \\varphi(p)}\\pmod p$$ 于是就有了$\\ f\\ $的递推式，可以直接递归计算 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int phi(int x) &#123; int res = x; for (int i = 2; i * i &lt;= x; ++i) &#123; if (x % i == 0) &#123; res /= i, res *= i - 1; while (x % i == 0) x /= i; &#125; &#125; if(x ^ 1) res /= x, res *= x - 1; return res;&#125;int pow(ll a, int b, int MOD) &#123; ll ans = 1; while (b &gt; 0) &#123; if(b &amp; 1) ans = (ans * a) % MOD; a = (a * a) % MOD; b &gt;&gt;= 1; &#125; return ans % MOD;&#125;ll solve(ll p) &#123; if(p == 1) return 0; return pow(2, solve(phi(p)) + phi(p), p);&#125;int main() &#123; ll T, a; scanf(\"%d\", &amp;T); for (int i = 1; i &lt;= T; ++i) &#123; scanf(\"%d\", &amp;a); printf(\"%d\\n\", solve(a)); &#125; return 0;&#125; 番外这道题有一个十分神奇的地方，就是在BZOJ中，先预处理出欧拉函数各值程序会TLE，但是在Luogu中，等到执行后再求单个欧拉函数反而会TLE，好神奇呐$\\mathcal{Q \\omega Q}$。","categories":[{"name":"Solution","slug":"Solution","permalink":"http://Mkozex.github.io/categories/Solution/"}],"tags":[{"name":"Luogu","slug":"Luogu","permalink":"http://Mkozex.github.io/tags/Luogu/"},{"name":"数论","slug":"数论","permalink":"http://Mkozex.github.io/tags/数论/"},{"name":"Math","slug":"Math","permalink":"http://Mkozex.github.io/tags/Math/"},{"name":"欧拉定理","slug":"欧拉定理","permalink":"http://Mkozex.github.io/tags/欧拉定理/"},{"name":"扩展欧拉定理","slug":"扩展欧拉定理","permalink":"http://Mkozex.github.io/tags/扩展欧拉定理/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://Mkozex.github.io/tags/BZOJ/"}]},{"title":"「SDOI2010」古代猪文-CRT+Lucas定理","slug":"「SDOI2010」古代猪文","date":"2019-07-20T08:30:47.000Z","updated":"2020-02-25T14:44:19.536Z","comments":true,"path":"2019/07/20/「SDOI2010」古代猪文/","link":"","permalink":"http://Mkozex.github.io/2019/07/20/「SDOI2010」古代猪文/","excerpt":"这道题要让我们求的是$\\ G^{\\sum_{d|m}C^d_n} \\bmod 999911659\\ $。","text":"这道题要让我们求的是$\\ G^{\\sum_{d|m}C^d_n} \\bmod 999911659\\ $。 链接Luogu P2480 题解因为，根据欧拉定理推论$$\\ G^{\\sum_{d|m}C^d_n} \\bmod 999911659=G^{\\sum_{d|m}C^d_n \\bmod 999911658}$$并且，我们有$$999911658=2\\times 3\\times 4679 \\times 35617$$然后，我们就可以用 $\\mathrm{Lucas}$ 定理将 $C^d_n$ 算出来，并且计算出 $\\sum_{d|n}C^d_n$ 对 $ 2,3,4679， 35617 $ 取模的结果，记为 $ a_1, a_2, a_3, a_4 $ 。 之后，我们用中国剩余定理求解一下方程组：$$x\\equiv a_1 \\pmod 2$$ $$x\\equiv a_2 \\pmod 3$$ $$\\quad x\\equiv a_3 \\pmod {4679}$$ $$\\quad \\ \\ x\\equiv a_4 \\pmod {35617}$$ 最后，用快速幂求一下$\\ G^x\\ $即可 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define M 999911658using namespace std;typedef long long ll;ll n, g, v, fac[50002], a[5], b[5] = &#123;0, 2, 3, 4679, 35617&#125;, D[5], N[5], y[5];ll pow(ll a, ll b, ll MOD) &#123; ll ans = 1; while (b &gt; 0) &#123; if(b &amp; 1) ans = (ans * a) % MOD; a = (a * a) % MOD; b &gt;&gt;= 1; &#125; return ans % MOD;&#125;void F(ll p) &#123; fac[0] = 1; for (ll i = 1; i &lt;= p; ++i) fac[i] = fac[i - 1] * i % p;&#125;ll C(ll n, ll m, ll p) &#123; if (n &lt; m) return 0; return frac[n] * pow(fac[m], p - 2, p) % p * pow(fac[n - m], p - 2, p) % p;&#125;ll Lucas(ll n, ll m, ll p) &#123; if (n &lt; m) return 0; if (!n) return 1; return Lucas(n / p, m / p, p) * C(n % p, m % p, p) % p;&#125;void crt() &#123; for(int i = 1; i &lt;= 4; i++) v = (v + a[i] * (M / b[i]) % M * pow(M / b[i], b[i] - 2, b[i])) % M;&#125;int main() &#123; scanf(\"%lld%lld\", &amp;n, &amp;g); if (g % (M + 1) == 0) &#123; printf(\"0\\n\"); return 0; &#125; for (ll i = 1; i &lt;= 4; ++i) &#123; F(b[i]); for (ll j = 1; j * j &lt;= n; ++j) &#123; if (n % j == 0) &#123; a[i] = (a[i] + Lucas(n, j, b[i])) % b[i]; if (j * j != n) a[i] = (a[i] + Lucas(n, n / j, b[i])) % b[i]; &#125; &#125; &#125; crt(); printf(\"%lld\\n\", pow(g, v, M + 1)); return 0;&#125;","categories":[{"name":"Solution","slug":"Solution","permalink":"http://Mkozex.github.io/categories/Solution/"}],"tags":[{"name":"Luogu","slug":"Luogu","permalink":"http://Mkozex.github.io/tags/Luogu/"},{"name":"数论","slug":"数论","permalink":"http://Mkozex.github.io/tags/数论/"},{"name":"Math","slug":"Math","permalink":"http://Mkozex.github.io/tags/Math/"},{"name":"欧拉定理","slug":"欧拉定理","permalink":"http://Mkozex.github.io/tags/欧拉定理/"},{"name":"Lucas定理","slug":"Lucas定理","permalink":"http://Mkozex.github.io/tags/Lucas定理/"},{"name":"CRT","slug":"CRT","permalink":"http://Mkozex.github.io/tags/CRT/"}]},{"title":"Miller-Rabin素性检测","slug":"Miller-Rabin素性检测","date":"2019-06-08T05:01:32.000Z","updated":"2019-10-10T14:04:11.042Z","comments":true,"path":"2019/06/08/Miller-Rabin素性检测/","link":"","permalink":"http://Mkozex.github.io/2019/06/08/Miller-Rabin素性检测/","excerpt":"我们常用的单个素数检测复杂度为$\\ O(\\sqrt{n})\\ $，当$\\ n \\ $很大时，这种方法就不适用了，于是我们就有了$\\mathrm{Miller-Rabin}$素数判定方法，这种判定的复杂度可以降至$\\ O(k\\log ^3 n)$（其中$\\ k \\ $时测试的轮数）","text":"我们常用的单个素数检测复杂度为$\\ O(\\sqrt{n})\\ $，当$\\ n \\ $很大时，这种方法就不适用了，于是我们就有了$\\mathrm{Miller-Rabin}$素数判定方法，这种判定的复杂度可以降至$\\ O(k\\log ^3 n)$（其中$\\ k \\ $时测试的轮数） 关于费马小定理对于$\\mathrm{Miller-Rabin}$算法， 有人可能会说，直接用费马小定理啊。确实，我们可以根据费马小定理得出一种检验素数的思路：不断的选取$\\ [2,n-1]\\ $中的基$\\ a \\ $，并检测是否都有$\\ a^{n-1}\\equiv 1 \\pmod n$而很遗憾的是，费马小定理的逆定理并不成立，也就是，存在合数$\\ n \\ $使得对于$\\ [2,n-1]\\ $中的每一个数，$\\ a^{n-1}\\equiv 1 \\pmod n$均成立。由此，我们引出了卡迈克尔数$(\\mathrm{Carmichael\\ Number})$ 卡迈克尔数卡迈克尔数$(\\mathrm{Carmichael\\ Number})$指的是对于$\\ [2,n-1]\\ $中的每一个数，$\\ a^{n-1}\\equiv 1 \\pmod n$均成立的合数$\\ n \\ $。比如$\\ 341\\ $就是一个卡迈克尔数。而且我们可以知道：如果$\\ n \\ $是一个卡迈克尔数，则$\\ m=2^n+1\\ $也一定是一个卡迈克尔数，因此，卡迈克尔数的个数是无穷的。 二次探测定理二次探测定理指的是：如果$\\ p \\ $是一个奇素数，则$\\ x^2\\equiv 1 \\pmod p\\ $的解为$\\ x=1\\ $或者$\\ x=p-1 \\pmod p\\ $ $\\mathrm{Miller-Rabin}\\ $算法有了那么多的东西，所以我们不妨将费马小定理与二次探测定理结合起来使用，一起来对付那些卡迈克尔数：对于$\\ n \\ $，我们可以将$\\ n-1\\ $分解为$\\ n-1=u\\times 2^t\\ $，然后不断地对$\\ u\\ $进行平方，如果发现了非平凡平方根，则可判定$\\ n\\ $不是素数。 代码12345678910111213141516bool MR(int n) &#123; if (n &lt; 3) return n == 2; int a = n - 1, b = 0; while (a % 2 == 0) a /= 2, ++b; // k为测试次数 for (int i = 1, j; i &lt;= k; ++i) &#123; int x = rand() % (n - 2) + 2, v = pow(x, a, n); if (v == 1 || v == n - 1) continue; for (j = 0; j &lt; b; ++j) &#123; v = (long long)v * v % n; if (v == n - 1) break; &#125; if (j &gt;= b) return false; &#125; return true;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://Mkozex.github.io/categories/Algorithm/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Mkozex.github.io/tags/学习笔记/"},{"name":"数论","slug":"数论","permalink":"http://Mkozex.github.io/tags/数论/"},{"name":"素数","slug":"素数","permalink":"http://Mkozex.github.io/tags/素数/"},{"name":"Math","slug":"Math","permalink":"http://Mkozex.github.io/tags/Math/"}]},{"title":"乘法逆元","slug":"乘法逆元","date":"2019-04-20T12:35:01.000Z","updated":"2019-10-10T14:04:45.873Z","comments":true,"path":"2019/04/20/乘法逆元/","link":"","permalink":"http://Mkozex.github.io/2019/04/20/乘法逆元/","excerpt":"乘法逆元是OI中一个很重要的数论算法，那么，该如何高效的求出乘法逆元呢？$P.S.$这里我们只讨论当模数为素数的情况，因为如果模数不为素数，则不一定每个数都有逆元。","text":"乘法逆元是OI中一个很重要的数论算法，那么，该如何高效的求出乘法逆元呢？$P.S.$这里我们只讨论当模数为素数的情况，因为如果模数不为素数，则不一定每个数都有逆元。 定义我们将$\\ x\\ $在$\\ \\mathrm{mod}\\ p\\ $意义下的乘法逆元称为$\\ x^{-1}\\ $。其有如下性质：$$x\\times x^{-1} \\equiv1 \\pmod p$$ 费马小定理$$a^{p-1}\\equiv 1 \\pmod p$$这个式子可以变形为$$a\\times a^{p-2}\\equiv1 \\pmod p$$所以可得，其中的$\\ a^{p-2}\\ $即为$\\ a\\ $的乘法逆元。而对于计算$\\ a^{p-2}\\ $,我们可以使用快速幂，时间复杂度为$O(\\log a)$。 代码1234567891011121314int pow(int a, int b) &#123; int ans = 1; while (b &gt; 0) &#123; if(b &amp; 1) ans = (ans * a) % MOD; a = (a * a) % MOD; b &gt;&gt;= 1; &#125; return ans % MOD;&#125;int inv(int num) &#123; return pow(num, MOD - 2);&#125; 扩展欧里里得扩展欧几里得算法本来就是用来求解形如$$ax+by=\\gcd(a,b)$$的方程的一组整数解。而当$\\ b \\ $为素数时，$\\ \\gcd(a,b)=1$,所以有$$ax\\equiv1 \\pmod b$$因此其中的$\\ a\\ $为$\\ x \\ $的乘法逆元。时间复杂度为$O(\\log a)$ 代码12345678910void exgcd(int a,int b, int &amp;g, int &amp;x, int &amp;y) &#123; if (!b) g = a, x = 1, y = 0; else exgcd(b, a % b, g, y, x), y -= x * (a / b);&#125;int inv(const int num) &#123; int g, x, y; exgcd(num, p, g, x, y); return ((x % p) + p) % p;&#125; 递推法如果设$\\ p=m\\times i + n\\ $,$\\ (n &lt;i,1&lt;i&lt;p)\\ $则有$$m\\times i +n \\equiv 0\\pmod p$$这时如果在两边同时乘上$\\ n^{-1}+i^{-1}\\ $，即可得$$m\\times n^{-1}+i^{-1}\\equiv 0 \\pmod p$$即$$i^{-1}\\equiv -\\lfloor \\frac{p}{i} \\rfloor\\times(p \\bmod i)^{-1} \\pmod p$$于是我们可以用此式来推，可得边界条件为$1^{-1}\\equiv 1\\pmod p$，于是此算法的时间复杂度为$O(n)$ 代码123inv[1] = 1;for (int i = 2; i &lt;= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://Mkozex.github.io/categories/Algorithm/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Mkozex.github.io/tags/学习笔记/"},{"name":"数论","slug":"数论","permalink":"http://Mkozex.github.io/tags/数论/"},{"name":"Math","slug":"Math","permalink":"http://Mkozex.github.io/tags/Math/"},{"name":"乘法逆元","slug":"乘法逆元","permalink":"http://Mkozex.github.io/tags/乘法逆元/"}]},{"title":"裴蜀定理与ex-gcd","slug":"裴蜀定理与ex-gcd","date":"2019-03-31T08:30:47.000Z","updated":"2019-10-10T14:04:57.066Z","comments":true,"path":"2019/03/31/裴蜀定理与ex-gcd/","link":"","permalink":"http://Mkozex.github.io/2019/03/31/裴蜀定理与ex-gcd/","excerpt":"$\\ \\mathrm{ex-gcd}\\ $可以求解形如$\\ ax+by=c\\ $的不定方程，而裴蜀定理则作为其的理论依据，是个十分重要的算法（废话","text":"$\\ \\mathrm{ex-gcd}\\ $可以求解形如$\\ ax+by=c\\ $的不定方程，而裴蜀定理则作为其的理论依据，是个十分重要的算法（废话 首先是裴蜀定理 裴蜀定理的内容裴蜀定理,它指的是$$\\mathrm{gcd}(a,b)|d\\Leftrightarrow\\exists u,v\\ such \\ that\\ ua+vb=d$$ 裴蜀定理的证明首先当$u=1\\ ,\\ v=0$时，结论成立假设存在$u’\\ ,\\ v’$使得$\\ u’b+v’(a\\bmod{b})=d$因为$$\\mathrm{gcd}(a,b)=\\mathrm{gcd}(b,a\\bmod{b}))$$因为$$a\\bmod{b}=a-\\left\\lfloor \\frac{a}{b}\\right\\rfloor b$$可得$$u’b+v’(a-\\left\\lfloor \\frac{a}{b}\\right\\rfloor b)=d$$整理可得$$v’a+(u’-\\left\\lfloor \\frac{a}{b}\\right\\rfloor v’)b=d$$归纳证明该定理正确 裴蜀定理的推广由此可推广至多项时的情景：方程$a_1x_1+a_2x_2+\\cdots+a_ix_i=f$有解的充要条件为$\\mathrm{gcd} (a_1,a_2,\\cdots a_i)|f$还可将其拓展为求$ax+by=c$中的最小非负的$c$，易得其解为$\\mathrm{gcd}(a,b)$ $\\mathrm{ex-gcd}$既然有了裴蜀定理，那我们就可以借此来求解满足$\\ ax+by=\\mathrm{gcd}(a,b)\\ $的解$ \\ x\\ , \\ y$首先，因为当$b=0\\ $时，有解为$\\ x=1\\ ,\\ y=0\\ $，所以就得出了递归边界所以可以得出代码： 1234567void ex_gcd (int a, int b, int &amp;g, int &amp;x, int &amp;y) &#123; if (!b) x = 1, y = 0, g = a; else &#123; ex_gcd(b, a % b, g, y, x); y -= a / b * x;//因为递归不影响最后结果，所以在最后减去a / b * x即可 &#125;&#125; 一道题求满足$\\ Ax+By=C\\ $的任意一组解 题解我们不妨先求出满足$\\ Ax+By=\\mathrm{gcd}(A,B)$的解，而这是上述方程的一组特解，接下来只需判断$\\mathrm{gcd}(A,B)|C$即可 代码1234567891011121314151617181920#include &lt;cstdio&gt;#define ll long long void ex_gcd (ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (!b) &#123;x = 1; y = 0;&#125; else &#123;ex_gcd(b, a % b, y, x); y -= a / b * x;&#125;&#125;int main() &#123; ll a, b, c, x = 0, y = 0, gcd; scanf(\"%lld %lld %lld\", &amp;a, &amp;b, &amp;c); c = -c; ex_gcd(a, b, x, y); gcd = a * x + b * y; if (c % gcd) return puts(\"-1\"), 0; x = c / gcd * x; y = c / gcd * y; printf(\"%lld %lld\\n\", x, y); return 0;&#125; 后记扩欧真好吃","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://Mkozex.github.io/categories/Algorithm/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Mkozex.github.io/tags/学习笔记/"},{"name":"数论","slug":"数论","permalink":"http://Mkozex.github.io/tags/数论/"},{"name":"Math","slug":"Math","permalink":"http://Mkozex.github.io/tags/Math/"},{"name":"欧几里得算法","slug":"欧几里得算法","permalink":"http://Mkozex.github.io/tags/欧几里得算法/"}]}]}